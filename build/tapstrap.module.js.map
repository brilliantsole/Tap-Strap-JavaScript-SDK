{"version":3,"file":"tapstrap.module.js","sources":["../node_modules/tslib/tslib.es6.js","../tapstrap/utils/environment.ts","../tapstrap/utils/Console.ts","../tapstrap/utils/EventDispatcher.ts","../tapstrap/utils/Timer.ts","../tapstrap/utils/Text.ts","../tapstrap/DeviceInformationManager.ts","../node_modules/auto-bind/index.js","../tapstrap/TapDataManager.ts","../tapstrap/MouseDataManager.ts","../tapstrap/AirGestureManager.ts","../tapstrap/utils/RawSensorUtils.ts","../tapstrap/utils/ArrayBufferUtils.ts","../tapstrap/RawSensorManager.ts","../tapstrap/TxManager.ts","../tapstrap/connection/BaseConnectionManager.ts","../tapstrap/utils/EventUtils.ts","../tapstrap/connection/bluetooth/bluetoothUUIDs.ts","../tapstrap/connection/bluetooth/BluetoothConnectionManager.ts","../tapstrap/connection/bluetooth/WebBluetoothConnectionManager.ts","../tapstrap/utils/MathUtils.ts","../tapstrap/VibrationManager.ts","../tapstrap/DeviceManager.ts","../tapstrap/InputManager.ts","../tapstrap/XRStateManager.ts","../tapstrap/Device.ts","../tapstrap/utils/RangeHelper.ts"],"sourcesContent":["/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise, SuppressedError, Symbol, Iterator */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\r\n    function accept(f) { if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\"); return f; }\r\n    var kind = contextIn.kind, key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\r\n    var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\r\n    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\r\n    var _, done = false;\r\n    for (var i = decorators.length - 1; i >= 0; i--) {\r\n        var context = {};\r\n        for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\r\n        for (var p in contextIn.access) context.access[p] = contextIn.access[p];\r\n        context.addInitializer = function (f) { if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\"); extraInitializers.push(accept(f || null)); };\r\n        var result = (0, decorators[i])(kind === \"accessor\" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);\r\n        if (kind === \"accessor\") {\r\n            if (result === void 0) continue;\r\n            if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\r\n            if (_ = accept(result.get)) descriptor.get = _;\r\n            if (_ = accept(result.set)) descriptor.set = _;\r\n            if (_ = accept(result.init)) initializers.unshift(_);\r\n        }\r\n        else if (_ = accept(result)) {\r\n            if (kind === \"field\") initializers.unshift(_);\r\n            else descriptor[key] = _;\r\n        }\r\n    }\r\n    if (target) Object.defineProperty(target, contextIn.name, descriptor);\r\n    done = true;\r\n};\r\n\r\nexport function __runInitializers(thisArg, initializers, value) {\r\n    var useValue = arguments.length > 2;\r\n    for (var i = 0; i < initializers.length; i++) {\r\n        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\r\n    }\r\n    return useValue ? value : void 0;\r\n};\r\n\r\nexport function __propKey(x) {\r\n    return typeof x === \"symbol\" ? x : \"\".concat(x);\r\n};\r\n\r\nexport function __setFunctionName(f, name, prefix) {\r\n    if (typeof name === \"symbol\") name = name.description ? \"[\".concat(name.description, \"]\") : \"\";\r\n    return Object.defineProperty(f, \"name\", { configurable: true, value: prefix ? \"\".concat(prefix, \" \", name) : name });\r\n};\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === \"function\" ? Iterator : Object).prototype);\r\n    return g.next = verb(0), g[\"throw\"] = verb(1), g[\"return\"] = verb(2), typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n        desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nexport function __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = Object.create((typeof AsyncIterator === \"function\" ? AsyncIterator : Object).prototype), verb(\"next\"), verb(\"throw\"), verb(\"return\", awaitReturn), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function awaitReturn(f) { return function (v) { return Promise.resolve(v).then(f, reject); }; }\r\n    function verb(n, f) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; if (f) i[n] = f(i[n]); } }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n\r\nexport function __classPrivateFieldIn(state, receiver) {\r\n    if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\r\n    return typeof state === \"function\" ? receiver === state : state.has(receiver);\r\n}\r\n\r\nexport function __addDisposableResource(env, value, async) {\r\n    if (value !== null && value !== void 0) {\r\n        if (typeof value !== \"object\" && typeof value !== \"function\") throw new TypeError(\"Object expected.\");\r\n        var dispose, inner;\r\n        if (async) {\r\n            if (!Symbol.asyncDispose) throw new TypeError(\"Symbol.asyncDispose is not defined.\");\r\n            dispose = value[Symbol.asyncDispose];\r\n        }\r\n        if (dispose === void 0) {\r\n            if (!Symbol.dispose) throw new TypeError(\"Symbol.dispose is not defined.\");\r\n            dispose = value[Symbol.dispose];\r\n            if (async) inner = dispose;\r\n        }\r\n        if (typeof dispose !== \"function\") throw new TypeError(\"Object not disposable.\");\r\n        if (inner) dispose = function() { try { inner.call(this); } catch (e) { return Promise.reject(e); } };\r\n        env.stack.push({ value: value, dispose: dispose, async: async });\r\n    }\r\n    else if (async) {\r\n        env.stack.push({ async: true });\r\n    }\r\n    return value;\r\n\r\n}\r\n\r\nvar _SuppressedError = typeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\r\n    var e = new Error(message);\r\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\r\n};\r\n\r\nexport function __disposeResources(env) {\r\n    function fail(e) {\r\n        env.error = env.hasError ? new _SuppressedError(e, env.error, \"An error was suppressed during disposal.\") : e;\r\n        env.hasError = true;\r\n    }\r\n    var r, s = 0;\r\n    function next() {\r\n        while (r = env.stack.pop()) {\r\n            try {\r\n                if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);\r\n                if (r.dispose) {\r\n                    var result = r.dispose.call(r.value);\r\n                    if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) { fail(e); return next(); });\r\n                }\r\n                else s |= 1;\r\n            }\r\n            catch (e) {\r\n                fail(e);\r\n            }\r\n        }\r\n        if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();\r\n        if (env.hasError) throw env.error;\r\n    }\r\n    return next();\r\n}\r\n\r\nexport function __rewriteRelativeImportExtension(path, preserveJsx) {\r\n    if (typeof path === \"string\" && /^\\.\\.?\\//.test(path)) {\r\n        return path.replace(/\\.(tsx)$|((?:\\.d)?)((?:\\.[^./]+?)?)\\.([cm]?)ts$/i, function (m, tsx, d, ext, cm) {\r\n            return tsx ? preserveJsx ? \".jsx\" : \".js\" : d && (!ext || !cm) ? m : (d + ext + \".\" + cm.toLowerCase() + \"js\");\r\n        });\r\n    }\r\n    return path;\r\n}\r\n\r\nexport default {\r\n    __extends: __extends,\r\n    __assign: __assign,\r\n    __rest: __rest,\r\n    __decorate: __decorate,\r\n    __param: __param,\r\n    __esDecorate: __esDecorate,\r\n    __runInitializers: __runInitializers,\r\n    __propKey: __propKey,\r\n    __setFunctionName: __setFunctionName,\r\n    __metadata: __metadata,\r\n    __awaiter: __awaiter,\r\n    __generator: __generator,\r\n    __createBinding: __createBinding,\r\n    __exportStar: __exportStar,\r\n    __values: __values,\r\n    __read: __read,\r\n    __spread: __spread,\r\n    __spreadArrays: __spreadArrays,\r\n    __spreadArray: __spreadArray,\r\n    __await: __await,\r\n    __asyncGenerator: __asyncGenerator,\r\n    __asyncDelegator: __asyncDelegator,\r\n    __asyncValues: __asyncValues,\r\n    __makeTemplateObject: __makeTemplateObject,\r\n    __importStar: __importStar,\r\n    __importDefault: __importDefault,\r\n    __classPrivateFieldGet: __classPrivateFieldGet,\r\n    __classPrivateFieldSet: __classPrivateFieldSet,\r\n    __classPrivateFieldIn: __classPrivateFieldIn,\r\n    __addDisposableResource: __addDisposableResource,\r\n    __disposeResources: __disposeResources,\r\n    __rewriteRelativeImportExtension: __rewriteRelativeImportExtension,\r\n};\r\n","type ENVIRONMENT_FLAG = \"__BRILLIANTSOLE__DEV__\" | \"__BRILLIANTSOLE__PROD__\";\nconst __BRILLIANTSOLE__ENVIRONMENT__: ENVIRONMENT_FLAG = \"__BRILLIANTSOLE__DEV__\";\n\n//@ts-expect-error\nconst isInProduction = __BRILLIANTSOLE__ENVIRONMENT__ == \"__BRILLIANTSOLE__PROD__\";\nconst isInDev = __BRILLIANTSOLE__ENVIRONMENT__ == \"__BRILLIANTSOLE__DEV__\";\n\n// https://github.com/flexdinesh/browser-or-node/blob/master/src/index.ts\nconst isInBrowser = typeof window !== \"undefined\" && typeof window?.document !== \"undefined\";\nconst isInNode = typeof process !== \"undefined\" && process?.versions?.node != null;\n\nconst userAgent = (isInBrowser && navigator.userAgent) || \"\";\n\nlet isBluetoothSupported = false;\nif (isInBrowser) {\n  isBluetoothSupported = Boolean(navigator.bluetooth);\n} else if (isInNode) {\n  isBluetoothSupported = true;\n}\n\nconst isInBluefy = isInBrowser && /Bluefy/i.test(userAgent);\nconst isInWebBLE = isInBrowser && /WebBLE/i.test(userAgent);\n\nconst isAndroid = isInBrowser && /Android/i.test(userAgent);\nconst isSafari = isInBrowser && /Safari/i.test(userAgent) && !/Chrome/i.test(userAgent);\n\nconst isIOS = isInBrowser && /iPad|iPhone|iPod/i.test(userAgent);\nconst isMac = isInBrowser && /Macintosh/i.test(userAgent);\n\n// @ts-expect-error\nconst isInLensStudio = !isInBrowser && !isInNode && typeof global !== \"undefined\" && typeof Studio !== \"undefined\";\n\nexport {\n  isInDev,\n  isInProduction,\n  isInBrowser,\n  isInNode,\n  isAndroid,\n  isInBluefy,\n  isInWebBLE,\n  isSafari,\n  isInLensStudio,\n  isIOS,\n  isMac,\n  isBluetoothSupported,\n};\n","import { isInDev, isInLensStudio } from \"./environment.ts\";\n\ndeclare var Studio: any | undefined;\n\nexport type LogFunction = (...data: any[]) => void;\nexport type AssertLogFunction = (condition: boolean, ...data: any[]) => void;\n\nexport interface ConsoleLevelFlags {\n  log?: boolean;\n  warn?: boolean;\n  error?: boolean;\n  assert?: boolean;\n  table?: boolean;\n}\n\ninterface ConsoleLike {\n  log?: LogFunction;\n  warn?: LogFunction;\n  error?: LogFunction;\n  assert?: AssertLogFunction;\n  table?: LogFunction;\n}\n\nvar __console: ConsoleLike;\nif (isInLensStudio) {\n  const log = function (...args: any[]) {\n    Studio.log(args.map((value) => new String(value)).join(\",\"));\n  };\n  __console = {};\n  __console.log = log;\n  __console.warn = log.bind(__console, \"WARNING\");\n  __console.error = log.bind(__console, \"ERROR\");\n} else {\n  __console = console;\n}\n\n// console.assert not supported in WebBLE\nif (!__console.assert) {\n  const assert: AssertLogFunction = (condition, ...data) => {\n    if (!condition) {\n      __console.warn!(...data);\n    }\n  };\n  __console.assert = assert;\n}\n\n// console.table not supported in WebBLE\nif (!__console.table) {\n  const table: LogFunction = (...data) => {\n    __console.log!(...data);\n  };\n  __console.table = table;\n}\n\nfunction emptyFunction() {}\n\nconst log: LogFunction = __console.log!.bind(__console);\nconst warn: LogFunction = __console.warn!.bind(__console);\nconst error: LogFunction = __console.error!.bind(__console);\nconst table: LogFunction = __console.table!.bind(__console);\nconst assert: AssertLogFunction = __console.assert.bind(__console);\n\nclass Console {\n  static #consoles: { [type: string]: Console } = {};\n\n  constructor(type: string) {\n    if (Console.#consoles[type]) {\n      throw new Error(`\"${type}\" console already exists`);\n    }\n    Console.#consoles[type] = this;\n  }\n\n  #levelFlags: ConsoleLevelFlags = {\n    log: isInDev,\n    warn: isInDev,\n    assert: true,\n    error: true,\n    table: true,\n  };\n\n  setLevelFlags(levelFlags: ConsoleLevelFlags) {\n    Object.assign(this.#levelFlags, levelFlags);\n  }\n\n  /** @throws {Error} if no console with type \"type\" is found */\n  static setLevelFlagsForType(type: string, levelFlags: ConsoleLevelFlags) {\n    if (!this.#consoles[type]) {\n      throw new Error(`no console found with type \"${type}\"`);\n    }\n    this.#consoles[type].setLevelFlags(levelFlags);\n  }\n\n  static setAllLevelFlags(levelFlags: ConsoleLevelFlags) {\n    for (const type in this.#consoles) {\n      this.#consoles[type].setLevelFlags(levelFlags);\n    }\n  }\n\n  static create(type: string, levelFlags?: ConsoleLevelFlags): Console {\n    const console = this.#consoles[type] || new Console(type);\n    if (isInDev && levelFlags) {\n      console.setLevelFlags(levelFlags);\n    }\n    return console;\n  }\n\n  get log() {\n    return this.#levelFlags.log ? log : emptyFunction;\n  }\n\n  get warn() {\n    return this.#levelFlags.warn ? warn : emptyFunction;\n  }\n\n  get error() {\n    return this.#levelFlags.error ? error : emptyFunction;\n  }\n\n  get assert() {\n    return this.#levelFlags.assert ? assert : emptyFunction;\n  }\n\n  get table() {\n    return this.#levelFlags.table ? table : emptyFunction;\n  }\n\n  /** @throws {Error} if condition is not met */\n  assertWithError(condition: any, message: string) {\n    if (!Boolean(condition)) {\n      throw new Error(message);\n    }\n  }\n\n  /** @throws {Error} if value's type doesn't match */\n  assertTypeWithError(value: any, type: string) {\n    this.assertWithError(typeof value == type, `value ${value} of type \"${typeof value}\" not of type \"${type}\"`);\n  }\n\n  /** @throws {Error} if value's type doesn't match */\n  assertEnumWithError(value: string, enumeration: readonly string[]) {\n    this.assertWithError(enumeration.includes(value), `invalid enum \"${value}\"`);\n  }\n}\n\nexport function createConsole(type: string, levelFlags?: ConsoleLevelFlags): Console {\n  return Console.create(type, levelFlags);\n}\n\n/** @throws {Error} if no console with type is found */\nexport function setConsoleLevelFlagsForType(type: string, levelFlags: ConsoleLevelFlags) {\n  Console.setLevelFlagsForType(type, levelFlags);\n}\n\nexport function setAllConsoleLevelFlags(levelFlags: ConsoleLevelFlags) {\n  Console.setAllLevelFlags(levelFlags);\n}\n","import { createConsole } from \"./Console.ts\";\nimport { deepEqual } from \"./ObjectUtils.ts\";\n\nconst _console = createConsole(\"EventDispatcher\", { log: false });\n\nexport type EventMap<\n  Target extends any,\n  EventType extends string,\n  EventMessages extends Partial<Record<EventType, any>>\n> = {\n  [T in keyof EventMessages]: { type: T; target: Target; message: EventMessages[T] };\n};\nexport type EventListenerMap<\n  Target extends any,\n  EventType extends string,\n  EventMessages extends Partial<Record<EventType, any>>\n> = {\n  [T in keyof EventMessages]: (event: { type: T; target: Target; message: EventMessages[T] }) => void;\n};\n\nexport type Event<\n  Target extends any,\n  EventType extends string,\n  EventMessages extends Partial<Record<EventType, any>>\n> = EventMap<Target, EventType, EventMessages>[keyof EventMessages];\n\ntype SpecificEvent<\n  Target extends any,\n  EventType extends string,\n  EventMessages extends Partial<Record<EventType, any>>,\n  SpecificEventType extends EventType\n> = { type: SpecificEventType; target: Target; message: EventMessages[SpecificEventType] };\n\nexport type BoundEventListeners<\n  Target extends any,\n  EventType extends string,\n  EventMessages extends Partial<Record<EventType, any>>\n> = {\n  [SpecificEventType in keyof EventMessages]?: (\n    // @ts-expect-error\n    event: SpecificEvent<Target, EventType, EventMessages, SpecificEventType>\n  ) => void;\n};\n\nclass EventDispatcher<\n  Target extends any,\n  EventType extends string,\n  EventMessages extends Partial<Record<EventType, any>>\n> {\n  private listeners: {\n    [T in EventType]?: {\n      listener: (event: { type: T; target: Target; message: EventMessages[T] }) => void;\n      once?: boolean;\n      shouldRemove?: boolean;\n    }[];\n  } = {};\n\n  constructor(private target: Target, private validEventTypes: readonly EventType[]) {\n    this.addEventListener = this.addEventListener.bind(this);\n    this.removeEventListener = this.removeEventListener.bind(this);\n    this.removeEventListeners = this.removeEventListeners.bind(this);\n    this.removeAllEventListeners = this.removeAllEventListeners.bind(this);\n    this.dispatchEvent = this.dispatchEvent.bind(this);\n    this.waitForEvent = this.waitForEvent.bind(this);\n  }\n\n  private isValidEventType(type: any): type is EventType {\n    return this.validEventTypes.includes(type);\n  }\n\n  private updateEventListeners(type: EventType) {\n    if (!this.listeners[type]) return;\n    this.listeners[type] = this.listeners[type]!.filter((listenerObj) => {\n      if (listenerObj.shouldRemove) {\n        _console.log(`removing \"${type}\" eventListener`, listenerObj);\n      }\n      return !listenerObj.shouldRemove;\n    });\n  }\n\n  addEventListener<T extends EventType>(\n    type: T,\n    listener: (event: { type: T; target: Target; message: EventMessages[T] }) => void,\n    options: { once?: boolean } = { once: false }\n  ): void {\n    if (!this.isValidEventType(type)) {\n      throw new Error(`Invalid event type: ${type}`);\n    }\n\n    if (!this.listeners[type]) {\n      this.listeners[type] = [];\n      _console.log(`creating \"${type}\" listeners array`, this.listeners[type]!);\n    }\n    const alreadyAdded = this.listeners[type].find((listenerObject) => {\n      return listenerObject.listener == listener && listenerObject.once == options.once;\n    });\n    if (alreadyAdded) {\n      _console.log(\"already added listener\");\n      return;\n    }\n    _console.log(`adding \"${type}\" listener`, listener, options);\n    this.listeners[type]!.push({ listener, once: options.once });\n\n    _console.log(`currently have ${this.listeners[type]!.length} \"${type}\" listeners`);\n  }\n\n  removeEventListener<T extends EventType>(\n    type: T,\n    listener: (event: { type: T; target: Target; message: EventMessages[T] }) => void\n  ): void {\n    if (!this.isValidEventType(type)) {\n      throw new Error(`Invalid event type: ${type}`);\n    }\n\n    if (!this.listeners[type]) return;\n\n    _console.log(`removing \"${type}\" listener...`, listener);\n    this.listeners[type]!.forEach((listenerObj) => {\n      const isListenerToRemove = listenerObj.listener === listener;\n      if (isListenerToRemove) {\n        _console.log(`flagging \"${type}\" listener`, listener);\n        listenerObj.shouldRemove = true;\n      }\n    });\n\n    this.updateEventListeners(type);\n  }\n\n  removeEventListeners<T extends EventType>(type: T): void {\n    if (!this.isValidEventType(type)) {\n      throw new Error(`Invalid event type: ${type}`);\n    }\n\n    if (!this.listeners[type]) return;\n\n    _console.log(`removing \"${type}\" listeners...`);\n    this.listeners[type] = [];\n  }\n\n  removeAllEventListeners(): void {\n    _console.log(`removing listeners...`);\n    this.listeners = {};\n  }\n\n  dispatchEvent<T extends EventType>(type: T, message: EventMessages[T]): void {\n    if (!this.isValidEventType(type)) {\n      throw new Error(`Invalid event type: ${type}`);\n    }\n\n    if (!this.listeners[type]) return;\n\n    this.listeners[type]!.forEach((listenerObj) => {\n      if (listenerObj.shouldRemove) {\n        return;\n      }\n\n      _console.log(`dispatching \"${type}\" listener`, listenerObj);\n      listenerObj.listener({ type, target: this.target, message });\n\n      if (listenerObj.once) {\n        _console.log(`flagging \"${type}\" listener`, listenerObj);\n        listenerObj.shouldRemove = true;\n      }\n    });\n    this.updateEventListeners(type);\n  }\n\n  waitForEvent<T extends EventType>(type: T): Promise<{ type: T; target: Target; message: EventMessages[T] }> {\n    return new Promise((resolve) => {\n      const onceListener = (event: { type: T; target: Target; message: EventMessages[T] }) => {\n        resolve(event);\n      };\n\n      this.addEventListener(type, onceListener, { once: true });\n    });\n  }\n}\n\nexport default EventDispatcher;\n","import { createConsole } from \"./Console.ts\";\n\nconst _console = createConsole(\"Timer\", { log: false });\n\nexport async function wait(delay: number) {\n  _console.log(`waiting for ${delay} ms`);\n  return new Promise((resolve: Function) => {\n    setTimeout(() => resolve(), delay);\n  });\n}\n\nclass Timer {\n  #callback!: Function;\n  get callback() {\n    return this.#callback;\n  }\n  set callback(newCallback) {\n    _console.assertTypeWithError(newCallback, \"function\");\n    _console.log({ newCallback });\n    this.#callback = newCallback;\n    if (this.isRunning) {\n      this.restart();\n    }\n  }\n\n  #interval!: number;\n  get interval() {\n    return this.#interval;\n  }\n  set interval(newInterval) {\n    _console.assertTypeWithError(newInterval, \"number\");\n    _console.assertWithError(newInterval > 0, \"interval must be above 0\");\n    _console.log({ newInterval });\n    this.#interval = newInterval;\n    if (this.isRunning) {\n      this.restart();\n    }\n  }\n\n  constructor(callback: Function, interval: number) {\n    this.interval = interval;\n    this.callback = callback;\n  }\n\n  #intervalId: number | undefined;\n  get isRunning() {\n    return this.#intervalId != undefined;\n  }\n\n  start(immediately = false) {\n    if (this.isRunning) {\n      _console.log(\"interval already running\");\n      return;\n    }\n    _console.log(\"starting interval\");\n    this.#intervalId = setInterval(this.#callback, this.#interval);\n    if (immediately) {\n      this.#callback();\n    }\n  }\n  stop() {\n    if (!this.isRunning) {\n      _console.log(\"interval already not running\");\n      return;\n    }\n    _console.log(\"stopping interval\");\n    clearInterval(this.#intervalId);\n    this.#intervalId = undefined;\n  }\n  restart(startImmediately = false) {\n    this.stop();\n    this.start(startImmediately);\n  }\n}\nexport default Timer;\n","var _TextEncoder;\nif (typeof TextEncoder == \"undefined\") {\n  _TextEncoder = class {\n    encode(string: string) {\n      const encoding = Array.from(string).map((char) => char.charCodeAt(0));\n      return Uint8Array.from(encoding);\n    }\n  };\n} else {\n  _TextEncoder = TextEncoder;\n}\n\nvar _TextDecoder;\nif (typeof TextDecoder == \"undefined\") {\n  _TextDecoder = class {\n    decode(data: ArrayBuffer) {\n      const byteArray = Array.from(new Uint8Array(data));\n      return byteArray\n        .map((value) => {\n          return String.fromCharCode(value);\n        })\n        .join(\"\");\n    }\n  };\n} else {\n  _TextDecoder = TextDecoder;\n}\n\nexport const textEncoder = new _TextEncoder();\nexport const textDecoder = new _TextDecoder();\n","import Device from \"./Device.ts\";\nimport { createConsole } from \"./utils/Console.ts\";\nimport EventDispatcher from \"./utils/EventDispatcher.ts\";\nimport { textDecoder } from \"./utils/Text.ts\";\n\nconst _console = createConsole(\"DeviceInformationManager\", { log: true });\n\nexport interface PnpId {\n  source: \"Bluetooth\" | \"USB\";\n  vendorId: number;\n  productId: number;\n  productVersion: number;\n}\n\nexport interface DeviceInformation {\n  manufacturerName: string;\n  modelNumber: string;\n  softwareRevision: string;\n  hardwareRevision: string;\n  firmwareRevision: string;\n  pnpId: PnpId;\n  serialNumber: string;\n}\n\nexport const DeviceInformationMessageTypes = [\n  \"manufacturerName\",\n  \"modelNumber\",\n  \"softwareRevision\",\n  \"hardwareRevision\",\n  \"firmwareRevision\",\n  \"pnpId\",\n  \"serialNumber\",\n] as const;\nexport type DeviceInformationMessageType = (typeof DeviceInformationMessageTypes)[number];\n\nexport const DeviceInformationEventTypes = [...DeviceInformationMessageTypes, \"deviceInformation\"] as const;\nexport type DeviceInformationEventType = (typeof DeviceInformationEventTypes)[number];\n\nexport interface DeviceInformationEventMessages {\n  manufacturerName: { manufacturerName: string };\n  modelNumber: { modelNumber: string };\n  softwareRevision: { softwareRevision: string };\n  hardwareRevision: { hardwareRevision: string };\n  firmwareRevision: { firmwareRevision: string };\n  pnpId: { pnpId: PnpId };\n  serialNumber: { serialNumber: string };\n  deviceInformation: { deviceInformation: DeviceInformation };\n}\n\nexport type DeviceInformationEventDispatcher = EventDispatcher<\n  Device,\n  DeviceInformationEventType,\n  DeviceInformationEventMessages\n>;\n\nclass DeviceInformationManager {\n  eventDispatcher!: DeviceInformationEventDispatcher;\n  get #dispatchEvent() {\n    return this.eventDispatcher.dispatchEvent;\n  }\n\n  #information: Partial<DeviceInformation> = {};\n  get information() {\n    return this.#information as DeviceInformation;\n  }\n  clear() {\n    this.#information = {};\n  }\n  get #isComplete() {\n    return DeviceInformationMessageTypes.every((key) => {\n      switch (key as DeviceInformationMessageType) {\n        case \"modelNumber\":\n        case \"serialNumber\":\n          return true;\n          break;\n        default:\n          return key in this.#information;\n      }\n    });\n  }\n\n  #update(partialDeviceInformation: Partial<DeviceInformation>) {\n    _console.log({ partialDeviceInformation });\n    const deviceInformationNames = Object.keys(partialDeviceInformation) as (keyof DeviceInformation)[];\n    deviceInformationNames.forEach((deviceInformationName) => {\n      // @ts-expect-error\n      this.#dispatchEvent(deviceInformationName, {\n        [deviceInformationName]: partialDeviceInformation[deviceInformationName],\n      });\n    });\n\n    Object.assign(this.#information, partialDeviceInformation);\n    _console.log({ deviceInformation: this.#information });\n    if (this.#isComplete) {\n      _console.log(\"completed deviceInformation\");\n      this.#dispatchEvent(\"deviceInformation\", { deviceInformation: this.information });\n    }\n  }\n\n  parseMessage(messageType: DeviceInformationMessageType, dataView: DataView) {\n    _console.log({ messageType });\n\n    switch (messageType) {\n      case \"manufacturerName\":\n        const manufacturerName = textDecoder.decode(dataView.buffer);\n        _console.log({ manufacturerName });\n        this.#update({ manufacturerName });\n        break;\n      case \"modelNumber\":\n        const modelNumber = textDecoder.decode(dataView.buffer);\n        _console.log({ modelNumber });\n        this.#update({ modelNumber });\n        break;\n      case \"softwareRevision\":\n        const softwareRevision = textDecoder.decode(dataView.buffer);\n        _console.log({ softwareRevision });\n        this.#update({ softwareRevision });\n        break;\n      case \"hardwareRevision\":\n        const hardwareRevision = textDecoder.decode(dataView.buffer);\n        _console.log({ hardwareRevision });\n        this.#update({ hardwareRevision });\n        break;\n      case \"firmwareRevision\":\n        const firmwareRevision = textDecoder.decode(dataView.buffer);\n        _console.log({ firmwareRevision });\n        this.#update({ firmwareRevision });\n        break;\n      case \"pnpId\":\n        const pnpId: PnpId = {\n          source: dataView.getUint8(0) === 1 ? \"Bluetooth\" : \"USB\",\n          productId: dataView.getUint16(3, true),\n          productVersion: dataView.getUint16(5, true),\n          vendorId: 0,\n        };\n        if (pnpId.source == \"Bluetooth\") {\n          pnpId.vendorId = dataView.getUint16(1, true);\n        } else {\n          // no need to implement\n        }\n        _console.log({ pnpId });\n        this.#update({ pnpId });\n        break;\n      case \"serialNumber\":\n        const serialNumber = textDecoder.decode(dataView.buffer);\n        _console.log({ serialNumber });\n        // will only be used for node\n        break;\n      default:\n        throw Error(`uncaught messageType ${messageType}`);\n    }\n  }\n}\n\nexport default DeviceInformationManager;\n","// Gets all non-builtin properties up the prototype chain.\nconst getAllProperties = object => {\n\tconst properties = new Set();\n\n\tdo {\n\t\tfor (const key of Reflect.ownKeys(object)) {\n\t\t\tproperties.add([object, key]);\n\t\t}\n\t} while ((object = Reflect.getPrototypeOf(object)) && object !== Object.prototype);\n\n\treturn properties;\n};\n\nexport default function autoBind(self, {include, exclude} = {}) {\n\tconst filter = key => {\n\t\tconst match = pattern => typeof pattern === 'string' ? key === pattern : pattern.test(key);\n\n\t\tif (include) {\n\t\t\treturn include.some(match); // eslint-disable-line unicorn/no-array-callback-reference\n\t\t}\n\n\t\tif (exclude) {\n\t\t\treturn !exclude.some(match); // eslint-disable-line unicorn/no-array-callback-reference\n\t\t}\n\n\t\treturn true;\n\t};\n\n\tfor (const [object, key] of getAllProperties(self.constructor.prototype)) {\n\t\tif (key === 'constructor' || !filter(key)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst descriptor = Reflect.getOwnPropertyDescriptor(object, key);\n\t\tif (descriptor && typeof descriptor.value === 'function') {\n\t\t\tself[key] = self[key].bind(self);\n\t\t}\n\t}\n\n\treturn self;\n}\n","import { createConsole } from \"./utils/Console.ts\";\nimport autoBind from \"auto-bind\";\nimport EventDispatcher from \"./utils/EventDispatcher.ts\";\nimport Device from \"./Device.ts\";\n\nconst _console = createConsole(\"TapDataManager\");\n\nexport const TapDataMessageTypes = [\"tapData\"] as const;\nexport type TapDataMessageType = (typeof TapDataMessageTypes)[number];\n\nexport const TapDataEventTypes = [...TapDataMessageTypes] as const;\nexport type TapDataEventType = (typeof TapDataEventTypes)[number];\n\nexport interface TapDataEventMessages {}\n\nexport type TapDataEventDispatcher = EventDispatcher<Device, TapDataEventType, TapDataEventMessages>;\n\nclass TapDataManager {\n  eventDispatcher!: TapDataEventDispatcher;\n  get #dispatchEvent() {\n    return this.eventDispatcher.dispatchEvent;\n  }\n\n  constructor() {\n    autoBind(this);\n  }\n\n  parseMessage(messageType: TapDataMessageType, dataView: DataView) {\n    _console.log({ messageType });\n\n    switch (messageType) {\n      case \"tapData\":\n        // FILL\n        break;\n      default:\n        throw Error(`uncaught messageType ${messageType}`);\n    }\n  }\n}\n\nexport default TapDataManager;\n","import { createConsole } from \"./utils/Console.ts\";\nimport autoBind from \"auto-bind\";\nimport EventDispatcher from \"./utils/EventDispatcher.ts\";\nimport Device from \"./Device.ts\";\n\nconst _console = createConsole(\"MouseDataManager\");\n\nexport const MouseDataMessageTypes = [\"mouseData\"] as const;\nexport type MouseDataMessageType = (typeof MouseDataMessageTypes)[number];\n\nexport const MouseDataEventTypes = [...MouseDataMessageTypes] as const;\nexport type MouseDataEventType = (typeof MouseDataEventTypes)[number];\n\nexport interface MouseDataEventMessages {}\n\nexport type MouseDataEventDispatcher = EventDispatcher<Device, MouseDataEventType, MouseDataEventMessages>;\n\nclass MouseDataManager {\n  eventDispatcher!: MouseDataEventDispatcher;\n  get #dispatchEvent() {\n    return this.eventDispatcher.dispatchEvent;\n  }\n\n  constructor() {\n    autoBind(this);\n  }\n\n  parseMessage(messageType: MouseDataMessageType, dataView: DataView) {\n    _console.log({ messageType });\n\n    switch (messageType) {\n      case \"mouseData\":\n        // FILL\n        break;\n      default:\n        throw Error(`uncaught messageType ${messageType}`);\n    }\n  }\n}\n\nexport default MouseDataManager;\n","import { createConsole } from \"./utils/Console.ts\";\nimport autoBind from \"auto-bind\";\nimport EventDispatcher from \"./utils/EventDispatcher.ts\";\nimport Device from \"./Device.ts\";\n\nconst _console = createConsole(\"AirGestureManager\");\n\nexport const AirGestureMessageTypes = [\"airGesture\"] as const;\nexport type AirGestureMessageType = (typeof AirGestureMessageTypes)[number];\n\nexport const AirGestureEventTypes = [...AirGestureMessageTypes] as const;\nexport type AirGestureEventType = (typeof AirGestureEventTypes)[number];\n\nexport interface AirGestureEventMessages {}\n\nexport type AirGestureEventDispatcher = EventDispatcher<Device, AirGestureEventType, AirGestureEventMessages>;\n\nclass AirGestureManager {\n  eventDispatcher!: AirGestureEventDispatcher;\n  get #dispatchEvent() {\n    return this.eventDispatcher.dispatchEvent;\n  }\n\n  constructor() {\n    autoBind(this);\n  }\n\n  parseMessage(messageType: AirGestureMessageType, dataView: DataView) {\n    _console.log({ messageType });\n\n    switch (messageType) {\n      case \"airGesture\":\n        // FILL\n        break;\n      default:\n        throw Error(`uncaught messageType ${messageType}`);\n    }\n  }\n}\n\nexport default AirGestureManager;\n","import { createConsole } from \"./Console.ts\";\n\nconst _console = createConsole(\"RawSensorUtils\");\n\n// https://github.com/TapWithUs/tap-ios-sdk/blob/master/TAPKit-iOS/Helpers/RawSensorData/TAPRawSensorSensitivity.swift#L13\nexport const RawSensorTypes = [\"deviceAccelerometer\", \"imuGyroscope\", \"imuAccelerometer\"] as const;\nexport type RawSensorType = (typeof RawSensorTypes)[number];\n\nexport const RawSensorSensitivityFactors: { [rawSensorType in RawSensorType]: number[] } = {\n  deviceAccelerometer: [31.25, 3.90625, 7.8125, 15.625, 31.25],\n  imuGyroscope: [17.5, 4.375, 8.75, 17.5, 35, 70],\n  imuAccelerometer: [0.122, 0.061, 0.122, 0.244, 0.488],\n};\nexport type RawSensorSensitivity = { [rawSensorType in RawSensorType]: number };\nexport const DefaultRawSensorSensitivity: RawSensorSensitivity = {\n  deviceAccelerometer: 0,\n  imuGyroscope: 0,\n  imuAccelerometer: 0,\n};\n\n//https://github.com/TapWithUs/tap-ios-sdk/blob/master/TAPKit-iOS/Helpers/RawSensorData/RawSensorData.swift#L50\nexport const RawSensorDataTypes = [\"imu\", \"device\"] as const;\nexport type RawSensorDataType = (typeof RawSensorDataTypes)[number];\nexport const RawSensorDataLength: { [rawSensorDataType in RawSensorDataType]: number } = {\n  imu: 12,\n  device: 30,\n};\n\nexport function assertValidRawSensorSensitivityForType(rawSensorType: RawSensorType, index: number) {\n  const value = RawSensorSensitivityFactors[rawSensorType][index];\n  _console.assertWithError(\n    value != undefined,\n    `invalid RawSensorSensitivity index ${index} for sensor \"${rawSensorType}\" (got value ${value})`\n  );\n}\n\nexport function assertValidRawSensorSensitivity(sensitivity: RawSensorSensitivity) {\n  RawSensorTypes.forEach((rawSensorType) => {\n    const index = sensitivity[rawSensorType];\n    assertValidRawSensorSensitivityForType(rawSensorType, index);\n  });\n}\n\n// https://github.com/TapWithUs/tap-ios-sdk/blob/master/TAPKit-iOS/Helpers/RawSensorData/RawSensorData.swift#L60C5-L66C43\nexport const RawSensorImuTypes = [\"gyro\", \"accelerometer\"] as const;\nexport type RawSensorImuType = (typeof RawSensorImuTypes)[number];\n\nexport const RawSensorFingers = [\"thumb\", \"index\", \"middle\", \"ring\", \"pinky\"] as const;\nexport type RawSensorFinger = (typeof RawSensorFingers)[number];\n","import { createConsole } from \"./Console.ts\";\nimport { textEncoder } from \"./Text.ts\";\n\nconst _console = createConsole(\"ArrayBufferUtils\", { log: false });\n\nexport function concatenateArrayBuffers(...arrayBuffers: any[]): ArrayBuffer {\n  arrayBuffers = arrayBuffers.filter((arrayBuffer) => arrayBuffer != undefined || arrayBuffer != null);\n  arrayBuffers = arrayBuffers.map((arrayBuffer) => {\n    if (typeof arrayBuffer == \"number\") {\n      const number = arrayBuffer;\n      return Uint8Array.from([Math.floor(number)]);\n    } else if (typeof arrayBuffer == \"boolean\") {\n      const boolean = arrayBuffer;\n      return Uint8Array.from([boolean ? 1 : 0]);\n    } else if (typeof arrayBuffer == \"string\") {\n      const string = arrayBuffer;\n      return stringToArrayBuffer(string);\n    } else if (arrayBuffer instanceof Array) {\n      const array = arrayBuffer;\n      return concatenateArrayBuffers(...array);\n    } else if (arrayBuffer instanceof ArrayBuffer) {\n      return arrayBuffer;\n    } else if (\"buffer\" in arrayBuffer && arrayBuffer.buffer instanceof ArrayBuffer) {\n      const bufferContainer = arrayBuffer;\n      return bufferContainer.buffer;\n    } else if (arrayBuffer instanceof DataView) {\n      const dataView = arrayBuffer;\n      return dataView.buffer;\n    } else if (typeof arrayBuffer == \"object\") {\n      const object = arrayBuffer;\n      return objectToArrayBuffer(object);\n    } else {\n      return arrayBuffer;\n    }\n  });\n  arrayBuffers = arrayBuffers.filter((arrayBuffer) => arrayBuffer && \"byteLength\" in arrayBuffer);\n  const length = arrayBuffers.reduce((length, arrayBuffer) => length + arrayBuffer.byteLength, 0);\n  const uint8Array = new Uint8Array(length);\n  let byteOffset = 0;\n  arrayBuffers.forEach((arrayBuffer) => {\n    uint8Array.set(new Uint8Array(arrayBuffer), byteOffset);\n    byteOffset += arrayBuffer.byteLength;\n  });\n  return uint8Array.buffer;\n}\n\nexport function dataToArrayBuffer(data: Buffer) {\n  return data.buffer.slice(data.byteOffset, data.byteOffset + data.byteLength);\n}\n\nexport function stringToArrayBuffer(string: string) {\n  const encoding = textEncoder.encode(string);\n  return concatenateArrayBuffers(encoding.byteLength, encoding);\n}\n\nexport function objectToArrayBuffer(object: object) {\n  return stringToArrayBuffer(JSON.stringify(object));\n}\n\nexport function sliceDataView(dataView: DataView, begin: number, length?: number) {\n  let end;\n  if (length != undefined) {\n    end = dataView.byteOffset + begin + length;\n  }\n  _console.log({ dataView, begin, end, length });\n  return new DataView(dataView.buffer.slice(dataView.byteOffset + begin, end));\n}\n\nexport type FileLike = number[] | ArrayBuffer | DataView | URL | string | File;\n\nexport async function getFileBuffer(file: FileLike) {\n  let fileBuffer;\n  if (file instanceof Array) {\n    fileBuffer = Uint8Array.from(file);\n  } else if (file instanceof DataView) {\n    fileBuffer = file.buffer;\n  } else if (typeof file == \"string\" || file instanceof URL) {\n    const response = await fetch(file);\n    fileBuffer = await response.arrayBuffer();\n  } else if (file instanceof File) {\n    fileBuffer = await file.arrayBuffer();\n  } else if (file instanceof ArrayBuffer) {\n    fileBuffer = file;\n  } else {\n    throw { error: \"invalid file type\", file };\n  }\n  return fileBuffer;\n}\n","import { createConsole } from \"./utils/Console.ts\";\nimport autoBind from \"auto-bind\";\nimport EventDispatcher from \"./utils/EventDispatcher.ts\";\nimport Device from \"./Device.ts\";\nimport {\n  RawSensorDataLength,\n  RawSensorDataType,\n  RawSensorDataTypes,\n  RawSensorSensitivity,\n  RawSensorSensitivityFactors,\n  RawSensorType,\n} from \"./utils/RawSensorUtils.ts\";\nimport { sliceDataView } from \"./utils/ArrayBufferUtils.ts\";\nimport { Vector3 } from \"./utils/MathUtils.ts\";\n\nconst _console = createConsole(\"RawSensorManager\");\n\nexport const RawSensorMessageTypes = [\"rawSensor\"] as const;\nexport type RawSensorMessageType = (typeof RawSensorMessageTypes)[number];\n\nexport const RawSensorEventTypes = [...RawSensorMessageTypes, ...RawSensorDataTypes] as const;\nexport type RawSensorEventType = (typeof RawSensorEventTypes)[number];\n\nexport type RawSensorEventMessage = {\n  timestamp: number;\n  sensorDataType: RawSensorDataType;\n  points: Vector3[];\n};\nexport interface RawSensorEventMessages {\n  rawSensor: RawSensorEventMessage;\n  imu: RawSensorEventMessage;\n  device: RawSensorEventMessage;\n}\n\nexport type RawSensorEventDispatcher = EventDispatcher<Device, RawSensorEventType, RawSensorEventMessages>;\n\nclass RawSensorManager {\n  eventDispatcher!: RawSensorEventDispatcher;\n  get #dispatchEvent() {\n    return this.eventDispatcher.dispatchEvent;\n  }\n\n  sensitivity!: RawSensorSensitivity;\n\n  constructor() {\n    autoBind(this);\n  }\n\n  parseMessage(messageType: RawSensorMessageType, dataView: DataView) {\n    _console.log({ messageType });\n\n    switch (messageType) {\n      case \"rawSensor\":\n        // FILL\n        this.#parseWhole(dataView);\n        break;\n      default:\n        throw Error(`uncaught messageType ${messageType}`);\n    }\n  }\n\n  // https://github.com/TapWithUs/tap-ios-sdk/blob/master/TAPKit-iOS/Helpers/RawSensorData/RawSensorDataParser.swift#L15\n  #parseWhole(dataView: DataView) {\n    _console.log(\"parsing whole\", dataView);\n\n    let offset = 0;\n    while (offset + 4 < dataView.byteLength) {\n      const rawValue = dataView.getUint32(0, true);\n      offset += 4;\n      _console.log({ rawValue });\n\n      const firstBit = (rawValue & 0x80000000) >> 31;\n      const timestamp = rawValue & 0x7fffffff;\n      _console.log({ firstBit, timestamp });\n      if (timestamp == 0) {\n        break;\n      }\n\n      const sensorDataType: RawSensorDataType = firstBit == 0 ? \"imu\" : \"device\";\n      _console.log({ sensorDataType });\n\n      const sensorDataLength = RawSensorDataLength[sensorDataType];\n      _console.log({ sensorDataLength });\n      if (sensorDataLength == 0) {\n        break;\n      }\n\n      const sensorData = sliceDataView(dataView, offset, sensorDataLength);\n      if (sensorData.byteLength == sensorDataLength) {\n        this.#parseSingle(sensorDataType, timestamp, sensorData);\n      }\n\n      offset += sensorDataLength;\n    }\n  }\n\n  // https://github.com/TapWithUs/tap-ios-sdk/blob/master/TAPKit-iOS/Helpers/RawSensorData/RawSensorData.swift#L80\n  #parseSingle(sensorDataType: RawSensorDataType, timestamp: number, sensorData: DataView) {\n    _console.log(`parsing ${sensorDataType} ${timestamp}ms`, sensorData);\n    let rawSensorType: RawSensorType = sensorDataType == \"device\" ? \"deviceAccelerometer\" : \"imuGyroscope\";\n\n    const points: Vector3[] = [];\n    for (let offset = 0; offset < sensorData.byteLength; offset += 6) {\n      const sensitivityFactorIndex = this.sensitivity[rawSensorType];\n      const sensitivityFactor = RawSensorSensitivityFactors[rawSensorType][sensitivityFactorIndex];\n      const [x, y, z] = [\n        sensorData.getInt16(offset + 0, true),\n        sensorData.getInt16(offset + 2, true),\n        sensorData.getInt16(offset + 4, true),\n      ].map((value) => value * sensitivityFactor);\n      _console.log({ x, y, z });\n      const point: Vector3 = { x, y, z };\n      _console.log(\"point\", point);\n      points.push(point);\n      if (sensorDataType == \"imu\") {\n        rawSensorType = \"imuAccelerometer\";\n      }\n    }\n\n    let validNumberOfPoints = 0;\n    switch (sensorDataType) {\n      case \"imu\":\n        validNumberOfPoints = 2;\n        break;\n      case \"device\":\n        validNumberOfPoints = 5;\n        break;\n    }\n\n    if (points.length != validNumberOfPoints) {\n      _console.log(\n        `invalid number of ${sensorDataType} points (expected ${validNumberOfPoints}, get ${points.length})`\n      );\n      return;\n    }\n\n    this.#dispatchEvent(sensorDataType, { sensorDataType, points, timestamp });\n    this.#dispatchEvent(\"rawSensor\", { sensorDataType, points, timestamp });\n  }\n}\n\nexport default RawSensorManager;\n","import { createConsole } from \"./utils/Console.ts\";\nimport autoBind from \"auto-bind\";\nimport EventDispatcher from \"./utils/EventDispatcher.ts\";\nimport Device from \"./Device.ts\";\nimport RawSensorManager, {\n  RawSensorEventDispatcher,\n  RawSensorEventMessages,\n  RawSensorEventTypes,\n  RawSensorMessageTypes,\n} from \"./RawSensorManager.ts\";\nimport { RawSensorSensitivity } from \"./TS.ts\";\n\nconst _console = createConsole(\"TxManager\");\n\nexport const TxMessageTypes = [\"tx\", ...RawSensorMessageTypes] as const;\nexport type TxMessageType = (typeof TxMessageTypes)[number];\n\nexport const TxEventTypes = [...RawSensorEventTypes] as const;\nexport type TxEventType = (typeof TxEventTypes)[number];\n\nexport interface TxEventMessages extends RawSensorEventMessages {}\n\nexport type TxEventDispatcher = EventDispatcher<Device, TxEventType, TxEventMessages>;\n\nclass TxManager {\n  #eventDispatcher!: TxEventDispatcher;\n  get eventDispatcher() {\n    return this.#eventDispatcher;\n  }\n  set eventDispatcher(newEventDispatcher) {\n    this.#eventDispatcher = newEventDispatcher;\n    this.#rawSensorManager.eventDispatcher = newEventDispatcher as RawSensorEventDispatcher;\n  }\n  get #dispatchEvent() {\n    return this.eventDispatcher.dispatchEvent;\n  }\n\n  set rawSensorSensitivity(sensitivity: RawSensorSensitivity) {\n    this.#rawSensorManager.sensitivity = sensitivity;\n  }\n\n  constructor() {\n    autoBind(this);\n  }\n\n  parseMessage(messageType: TxMessageType, dataView: DataView) {\n    _console.log({ messageType });\n\n    switch (messageType) {\n      case \"tx\":\n        this.#rawSensorManager.parseMessage(\"rawSensor\", dataView);\n        break;\n      default:\n        throw Error(`uncaught messageType ${messageType}`);\n    }\n  }\n\n  #rawSensorManager = new RawSensorManager();\n}\n\nexport default TxManager;\n","import { createConsole } from \"../utils/Console.ts\";\nimport Timer from \"../utils/Timer.ts\";\n\nimport { DeviceInformationMessageTypes } from \"../DeviceInformationManager.ts\";\nimport { TapDataMessageTypes } from \"../TapDataManager.ts\";\nimport { MouseDataMessageTypes } from \"../MouseDataManager.ts\";\nimport { AirGestureMessageTypes } from \"../AirGestureManager.ts\";\nimport { TxMessageTypes } from \"../TxManager.ts\";\n\nconst _console = createConsole(\"BaseConnectionManager\", { log: true });\n\nexport const ConnectionTypes = [\"webBluetooth\", \"noble\", \"client\"] as const;\nexport type ConnectionType = (typeof ConnectionTypes)[number];\n\nexport const ConnectionStatuses = [\"notConnected\", \"connecting\", \"connected\", \"disconnecting\"] as const;\nexport type ConnectionStatus = (typeof ConnectionStatuses)[number];\n\nexport const ConnectionEventTypes = [...ConnectionStatuses, \"connectionStatus\", \"isConnected\"] as const;\nexport type ConnectionEventType = (typeof ConnectionEventTypes)[number];\n\nexport interface ConnectionStatusEventMessages {\n  notConnected: any;\n  connecting: any;\n  connected: any;\n  disconnecting: any;\n  connectionStatus: { connectionStatus: ConnectionStatus };\n  isConnected: { isConnected: boolean };\n}\n\nexport const BatteryLevelMessageTypes = [\"batteryLevel\"] as const;\nexport type BatteryLevelMessageType = (typeof BatteryLevelMessageTypes)[number];\n\nexport const ConnectionMessageTypes = [\n  ...BatteryLevelMessageTypes,\n  ...DeviceInformationMessageTypes,\n  ...TapDataMessageTypes,\n  ...MouseDataMessageTypes,\n  ...AirGestureMessageTypes,\n  ...TxMessageTypes,\n] as const;\nexport type ConnectionMessageType = (typeof ConnectionMessageTypes)[number];\n\nexport type ConnectionStatusCallback = (status: ConnectionStatus) => void;\nexport type MessageReceivedCallback = (messageType: ConnectionMessageType, dataView: DataView) => void;\nexport type MessagesReceivedCallback = () => void;\n\nexport type SendDataCallback = (data: ArrayBuffer) => Promise<void>;\n\nabstract class BaseConnectionManager {\n  abstract get bluetoothId(): string;\n  abstract get name(): string;\n\n  // CALLBACKS\n  onStatusUpdated?: ConnectionStatusCallback;\n  onMessageReceived?: MessageReceivedCallback;\n  onMessagesReceived?: MessagesReceivedCallback;\n\n  protected get baseConstructor() {\n    return this.constructor as typeof BaseConnectionManager;\n  }\n  static get isSupported() {\n    return false;\n  }\n  get isSupported() {\n    return this.baseConstructor.isSupported;\n  }\n\n  static type: ConnectionType;\n  get type(): ConnectionType {\n    return this.baseConstructor.type;\n  }\n\n  /** @throws {Error} if not supported */\n  #assertIsSupported() {\n    _console.assertWithError(this.isSupported, `${this.constructor.name} is not supported`);\n  }\n\n  constructor() {\n    this.#assertIsSupported();\n  }\n\n  #status: ConnectionStatus = \"notConnected\";\n  get status() {\n    return this.#status;\n  }\n  protected set status(newConnectionStatus) {\n    _console.assertEnumWithError(newConnectionStatus, ConnectionStatuses);\n    if (this.#status == newConnectionStatus) {\n      _console.log(`tried to assign same connection status \"${newConnectionStatus}\"`);\n      return;\n    }\n    _console.log(`new connection status \"${newConnectionStatus}\"`);\n    this.#status = newConnectionStatus;\n    this.onStatusUpdated!(this.status);\n\n    if (this.isConnected) {\n      this.#timer.start();\n    } else {\n      this.#timer.stop();\n    }\n  }\n\n  get isConnected() {\n    return this.status == \"connected\";\n  }\n\n  /** @throws {Error} if connected */\n  #assertIsNotConnected() {\n    _console.assertWithError(!this.isConnected, \"device is already connected\");\n  }\n  /** @throws {Error} if connecting */\n  #assertIsNotConnecting() {\n    _console.assertWithError(this.status != \"connecting\", \"device is already connecting\");\n  }\n  /** @throws {Error} if not connected */\n  #assertIsConnected() {\n    _console.assertWithError(this.isConnected, \"device is not connected\");\n  }\n  /** @throws {Error} if disconnecting */\n  #assertIsNotDisconnecting() {\n    _console.assertWithError(this.status != \"disconnecting\", \"device is already disconnecting\");\n  }\n  /** @throws {Error} if not connected or is disconnecting */\n  #assertIsConnectedAndNotDisconnecting() {\n    this.#assertIsConnected();\n    this.#assertIsNotDisconnecting();\n  }\n\n  async connect() {\n    this.#assertIsNotConnected();\n    this.#assertIsNotConnecting();\n    this.status = \"connecting\";\n  }\n  get canReconnect() {\n    return false;\n  }\n  async reconnect() {\n    this.#assertIsNotConnected();\n    this.#assertIsNotConnecting();\n    _console.assert(this.canReconnect, \"unable to reconnect\");\n  }\n  async disconnect() {\n    this.#assertIsConnected();\n    this.#assertIsNotDisconnecting();\n    this.status = \"disconnecting\";\n    _console.log(\"disconnecting from device...\");\n  }\n\n  async sendUICommandsData(data: ArrayBuffer) {\n    _console.log(\"sendUICommandsData\", data);\n  }\n\n  async sendRxData(data: ArrayBuffer) {\n    _console.log(\"sendRxData\", data);\n  }\n\n  #timer = new Timer(this.#checkConnection.bind(this), 5000);\n  #checkConnection() {\n    //console.log(\"checking connection...\");\n    if (!this.isConnected) {\n      _console.log(\"timer detected disconnection\");\n      this.status = \"notConnected\";\n    }\n  }\n}\n\nexport default BaseConnectionManager;\n","import { createConsole } from \"./Console.ts\";\nimport { spacesToPascalCase } from \"./stringUtils.ts\";\n\nconst _console = createConsole(\"EventUtils\", { log: false });\n\ntype BoundEventListeners = { [eventType: string]: EventListener };\nexport type BoundGenericEventListeners = { [eventType: string]: Function };\n\nexport function bindEventListeners(\n  eventTypes: readonly string[],\n  boundEventListeners: BoundGenericEventListeners,\n  target: any\n) {\n  _console.log(\"bindEventListeners\", { eventTypes, boundEventListeners, target });\n  eventTypes.forEach((eventType) => {\n    const _eventType = `_on${spacesToPascalCase(eventType)}`;\n    _console.assertWithError(target[_eventType], `no event \"${_eventType}\" found in target`);\n    _console.log(`binding eventType \"${eventType}\" as ${_eventType} from target`, target);\n    const boundEvent = target[_eventType].bind(target);\n    target[_eventType] = boundEvent;\n    boundEventListeners[eventType] = boundEvent;\n  });\n}\n\nexport function addEventListeners(target: any, boundEventListeners: BoundGenericEventListeners) {\n  let addEventListener = target.addEventListener || target.addListener || target.on || target.AddEventListener;\n  _console.assertWithError(addEventListener, \"no add listener function found for target\");\n  addEventListener = addEventListener.bind(target);\n  Object.entries(boundEventListeners).forEach(([eventType, eventListener]) => {\n    addEventListener(eventType, eventListener);\n  });\n}\n\nexport function removeEventListeners(target: any, boundEventListeners: BoundGenericEventListeners) {\n  let removeEventListener = target.removeEventListener || target.removeListener || target.RemoveEventListener;\n  _console.assertWithError(removeEventListener, \"no remove listener function found for target\");\n  removeEventListener = removeEventListener.bind(target);\n  Object.entries(boundEventListeners).forEach(([eventType, eventListener]) => {\n    removeEventListener(eventType, eventListener);\n  });\n}\n","import { isInBrowser, isInNode } from \"../../utils/environment.ts\";\nimport { createConsole } from \"../../utils/Console.ts\";\n\nconst _console = createConsole(\"bluetoothUUIDs\", { log: false });\n\n/** NODE_START */\nimport * as webbluetooth from \"webbluetooth\";\nvar BluetoothUUID = webbluetooth.BluetoothUUID;\n/** NODE_END */\n/** BROWSER_START */\nif (isInBrowser) {\n  var BluetoothUUID = window.BluetoothUUID;\n}\n/** BROWSER_END */\n\n//https://github.com/TapWithUs/tap-ios-sdk/blob/155ab66658662a19d39b231264a3efdd8b5b7e7b/TAPKit-iOS/Helpers/TAPCBUUID.swift#L57\nfunction generateTapBluetoothUUID(value: string): BluetoothServiceUUID {\n  _console.assertTypeWithError(value, \"string\");\n  _console.assertWithError(value.length == 1, \"value must be 1 character long\");\n  return `C3FF000${value}-1D8B-40FD-A56F-C7BD5D0F3370`.toLowerCase();\n}\n// https://github.com/TapWithUs/tap-ios-sdk/blob/155ab66658662a19d39b231264a3efdd8b5b7e7b/TAPKit-iOS/Helpers/TAPCBUUID.swift#L58\nfunction generateNUSBluetoothUUID(value: string): BluetoothServiceUUID {\n  _console.assertTypeWithError(value, \"string\");\n  _console.assertWithError(value.length == 1, \"value must be 1 character long\");\n  return `6E40000${value}-B5A3-F393-E0A9-E50E24DCCA9E`.toLowerCase();\n}\n\nfunction stringToCharacteristicUUID(identifier: string): BluetoothCharacteristicUUID {\n  return BluetoothUUID?.getCharacteristic?.(identifier);\n}\n\nfunction stringToServiceUUID(identifier: string): BluetoothServiceUUID {\n  return BluetoothUUID?.getService?.(identifier);\n}\n\nexport type BluetoothServiceName = \"deviceInformation\" | \"battery\" | \"tap\" | \"nus\";\nimport { DeviceInformationMessageType } from \"../../DeviceInformationManager.ts\";\nexport type BluetoothCharacteristicName =\n  | DeviceInformationMessageType\n  | \"batteryLevel\"\n  | \"tapData\"\n  | \"mouseData\"\n  | \"airGesture\"\n  | \"uiCommands\"\n  | \"settings\"\n  | \"unknown3\"\n  | \"unknown2\"\n  | \"unknown7\"\n  | \"unknown8\"\n  | \"unknownB\"\n  | \"unknownC\"\n  | \"unknownD\"\n  | \"rx\"\n  | \"tx\";\n\ninterface BluetoothCharacteristicInformation {\n  uuid: BluetoothCharacteristicUUID;\n}\ninterface BluetoothServiceInformation {\n  uuid: BluetoothServiceUUID;\n  characteristics: { [characteristicName in BluetoothCharacteristicName]?: BluetoothCharacteristicInformation };\n}\ninterface BluetoothServicesInformation {\n  services: { [serviceName in BluetoothServiceName]: BluetoothServiceInformation };\n}\n\nconst bluetoothUUIDs: BluetoothServicesInformation = Object.freeze({\n  services: {\n    deviceInformation: {\n      uuid: stringToServiceUUID(\"device_information\"),\n      characteristics: {\n        manufacturerName: {\n          uuid: stringToCharacteristicUUID(\"manufacturer_name_string\"),\n        },\n        modelNumber: {\n          uuid: stringToCharacteristicUUID(\"model_number_string\"),\n        },\n        hardwareRevision: {\n          uuid: stringToCharacteristicUUID(\"hardware_revision_string\"),\n        },\n        firmwareRevision: {\n          uuid: stringToCharacteristicUUID(\"firmware_revision_string\"),\n        },\n        softwareRevision: {\n          uuid: stringToCharacteristicUUID(\"software_revision_string\"),\n        },\n        pnpId: {\n          uuid: stringToCharacteristicUUID(\"pnp_id\"),\n        },\n        serialNumber: {\n          uuid: stringToCharacteristicUUID(\"serial_number_string\"),\n        },\n      },\n    },\n    battery: {\n      uuid: stringToServiceUUID(\"battery_service\"),\n      characteristics: {\n        batteryLevel: {\n          uuid: stringToCharacteristicUUID(\"battery_level\"),\n        },\n      },\n    },\n    tap: {\n      uuid: generateTapBluetoothUUID(\"1\"),\n      characteristics: {\n        tapData: { uuid: generateTapBluetoothUUID(\"5\") },\n        mouseData: { uuid: generateTapBluetoothUUID(\"6\") },\n        airGesture: { uuid: generateTapBluetoothUUID(\"A\") },\n        uiCommands: { uuid: generateTapBluetoothUUID(\"9\") },\n        settings: { uuid: generateTapBluetoothUUID(\"2\") },\n        unknown3: { uuid: generateTapBluetoothUUID(\"3\") },\n        unknown7: { uuid: generateTapBluetoothUUID(\"7\") },\n        unknown8: { uuid: generateTapBluetoothUUID(\"8\") },\n        unknownB: { uuid: generateTapBluetoothUUID(\"B\") },\n        unknownC: { uuid: generateTapBluetoothUUID(\"C\") },\n        unknownD: { uuid: generateTapBluetoothUUID(\"D\") },\n      },\n    },\n    nus: {\n      uuid: generateNUSBluetoothUUID(\"1\"),\n      characteristics: {\n        rx: { uuid: generateNUSBluetoothUUID(\"2\") },\n        tx: { uuid: generateNUSBluetoothUUID(\"3\") },\n      },\n    },\n  },\n});\n\nexport const serviceUUIDs = [bluetoothUUIDs.services.tap.uuid];\nexport const optionalServiceUUIDs = [\n  bluetoothUUIDs.services.deviceInformation.uuid,\n  bluetoothUUIDs.services.battery.uuid,\n  bluetoothUUIDs.services.nus.uuid,\n];\nexport const allServiceUUIDs = [...serviceUUIDs, ...optionalServiceUUIDs];\n\nexport function getServiceNameFromUUID(serviceUUID: BluetoothServiceUUID): BluetoothServiceName | undefined {\n  serviceUUID = serviceUUID.toString().toLowerCase();\n  const serviceNames = Object.keys(bluetoothUUIDs.services) as BluetoothServiceName[];\n  return serviceNames.find((serviceName) => {\n    const serviceInfo = bluetoothUUIDs.services[serviceName];\n    let serviceInfoUUID = serviceInfo.uuid.toString();\n    if (serviceUUID.length == 4) {\n      serviceInfoUUID = serviceInfoUUID.slice(4, 8);\n    }\n    if (!serviceUUID.includes(\"-\")) {\n      serviceInfoUUID = serviceInfoUUID.replaceAll(\"-\", \"\");\n    }\n    return serviceUUID == serviceInfoUUID;\n  });\n}\n\nexport const characteristicUUIDs: BluetoothCharacteristicUUID[] = [];\nexport const allCharacteristicUUIDs: BluetoothCharacteristicUUID[] = [];\n\nexport const characteristicNames: BluetoothCharacteristicName[] = [];\nexport const allCharacteristicNames: BluetoothCharacteristicName[] = [];\n\nObject.values(bluetoothUUIDs.services).forEach((serviceInfo) => {\n  if (!serviceInfo.characteristics) {\n    return;\n  }\n  const characteristicNames = Object.keys(serviceInfo.characteristics) as BluetoothCharacteristicName[];\n  characteristicNames.forEach((characteristicName) => {\n    const characteristicInfo = serviceInfo.characteristics[characteristicName]!;\n    if (serviceUUIDs.includes(serviceInfo.uuid)) {\n      characteristicUUIDs.push(characteristicInfo.uuid);\n      characteristicNames.push(characteristicName);\n    }\n    allCharacteristicUUIDs.push(characteristicInfo.uuid);\n    allCharacteristicNames.push(characteristicName);\n  });\n}, []);\n\n_console.log({ serviceUUIDs, optionalServiceUUIDs, characteristicUUIDs, allCharacteristicUUIDs });\n\nexport function getCharacteristicNameFromUUID(\n  characteristicUUID: BluetoothCharacteristicUUID\n): BluetoothCharacteristicName | undefined {\n  //_console.log({ characteristicUUID });\n  characteristicUUID = characteristicUUID.toString().toLowerCase();\n  var characteristicName: BluetoothCharacteristicName | undefined;\n  Object.values(bluetoothUUIDs.services).some((serviceInfo) => {\n    const characteristicNames = Object.keys(serviceInfo.characteristics) as BluetoothCharacteristicName[];\n    characteristicName = characteristicNames.find((_characteristicName) => {\n      const characteristicInfo = serviceInfo.characteristics[_characteristicName]!;\n      let characteristicInfoUUID = characteristicInfo.uuid.toString();\n      if (characteristicUUID.length == 4) {\n        characteristicInfoUUID = characteristicInfoUUID.slice(4, 8);\n      }\n      if (!characteristicUUID.includes(\"-\")) {\n        characteristicInfoUUID = characteristicInfoUUID.replaceAll(\"-\", \"\");\n      }\n      return characteristicUUID == characteristicInfoUUID;\n    });\n    return characteristicName;\n  });\n  return characteristicName;\n}\n\nexport function getCharacteristicProperties(\n  characteristicName: BluetoothCharacteristicName\n): BluetoothCharacteristicProperties {\n  const properties = {\n    broadcast: false,\n    read: true,\n    writeWithoutResponse: false,\n    write: false,\n    notify: false,\n    indicate: false,\n    authenticatedSignedWrites: false,\n    reliableWrite: false,\n    writableAuxiliaries: false,\n  };\n\n  // read\n  switch (characteristicName) {\n    case \"settings\":\n    case \"tapData\":\n    case \"mouseData\":\n    case \"unknown7\":\n    case \"unknown8\":\n      properties.read = false;\n      break;\n  }\n\n  // notify\n  switch (characteristicName) {\n    case \"batteryLevel\":\n    case \"tapData\":\n    case \"mouseData\":\n    case \"airGesture\":\n    case \"unknown8\":\n    case \"unknownB\":\n    case \"unknownC\":\n    case \"unknownD\":\n    case \"tx\":\n      properties.notify = true;\n      break;\n  }\n\n  // write without response\n  switch (characteristicName) {\n    case \"airGesture\":\n    case \"uiCommands\":\n    case \"unknown7\":\n    case \"unknownB\":\n      properties.writeWithoutResponse = true;\n      break;\n  }\n\n  // write\n  switch (characteristicName) {\n    case \"settings\":\n    case \"unknown3\":\n    case \"unknown7\":\n    case \"rx\":\n      properties.write = true;\n      break;\n  }\n\n  return properties;\n}\n","import { createConsole } from \"../../utils/Console.ts\";\nimport BaseConnectionManager from \"../BaseConnectionManager.ts\";\n\nconst _console = createConsole(\"BluetoothConnectionManager\", { log: true });\n\nimport { BluetoothCharacteristicName } from \"./bluetoothUUIDs.ts\";\n\nabstract class BluetoothConnectionManager extends BaseConnectionManager {\n  isInRange = true;\n\n  protected onCharacteristicValueChanged(characteristicName: BluetoothCharacteristicName, dataView: DataView) {\n    switch (characteristicName) {\n      case \"batteryLevel\":\n\n      case \"firmwareRevision\":\n      case \"hardwareRevision\":\n      case \"manufacturerName\":\n      case \"modelNumber\":\n      case \"pnpId\":\n      case \"serialNumber\":\n      case \"softwareRevision\":\n\n      case \"tapData\":\n      case \"mouseData\":\n      case \"airGesture\":\n      case \"tx\":\n        this.onMessageReceived?.(characteristicName, dataView);\n        break;\n      default:\n        break;\n    }\n  }\n\n  protected async writeCharacteristic(characteristicName: BluetoothCharacteristicName, data: ArrayBuffer) {\n    _console.log(\"writeCharacteristic\", ...arguments);\n  }\n\n  async sendUICommandsData(data: ArrayBuffer) {\n    super.sendUICommandsData(data);\n    await this.writeCharacteristic(\"uiCommands\", data);\n  }\n\n  async sendRxData(data: ArrayBuffer) {\n    super.sendRxData(data);\n    await this.writeCharacteristic(\"rx\", data);\n  }\n}\n\nexport default BluetoothConnectionManager;\n","import { createConsole } from \"../../utils/Console.ts\";\nimport { isInNode, isInBrowser, isInBluefy, isInWebBLE } from \"../../utils/environment.ts\";\nimport { addEventListeners, removeEventListeners } from \"../../utils/EventUtils.ts\";\nimport {\n  serviceUUIDs,\n  optionalServiceUUIDs,\n  getServiceNameFromUUID,\n  getCharacteristicNameFromUUID,\n  getCharacteristicProperties,\n} from \"./bluetoothUUIDs.ts\";\nimport BluetoothConnectionManager from \"./BluetoothConnectionManager.ts\";\nimport { BluetoothCharacteristicName, BluetoothServiceName } from \"./bluetoothUUIDs.ts\";\nimport { ConnectionType } from \"../BaseConnectionManager.ts\";\n\nconst _console = createConsole(\"WebBluetoothConnectionManager\", { log: true });\n\ntype WebBluetoothInterface = webbluetooth.Bluetooth | Bluetooth;\n\ninterface BluetoothService extends BluetoothRemoteGATTService {\n  name?: BluetoothServiceName;\n}\ninterface BluetoothCharacteristic extends BluetoothRemoteGATTCharacteristic {\n  name?: BluetoothCharacteristicName;\n}\n\nvar bluetooth: WebBluetoothInterface | undefined;\n/** NODE_START */\nimport * as webbluetooth from \"webbluetooth\";\nif (isInNode) {\n  bluetooth = webbluetooth.bluetooth;\n}\n/** NODE_END */\n\n/** BROWSER_START */\nif (isInBrowser) {\n  bluetooth = window.navigator.bluetooth;\n}\n/** BROWSER_END */\n\nclass WebBluetoothConnectionManager extends BluetoothConnectionManager {\n  get bluetoothId() {\n    return this.device?.id || \"\";\n  }\n  get name() {\n    return this.device?.name || \"\";\n  }\n\n  #boundBluetoothCharacteristicEventListeners: { [eventType: string]: EventListener } = {\n    characteristicvaluechanged: this.#onCharacteristicvaluechanged.bind(this),\n  };\n  #boundBluetoothDeviceEventListeners: { [eventType: string]: EventListener } = {\n    gattserverdisconnected: this.#onGattserverdisconnected.bind(this),\n  };\n\n  static get isSupported() {\n    return Boolean(bluetooth);\n  }\n  static get type(): ConnectionType {\n    return \"webBluetooth\";\n  }\n\n  #device!: BluetoothDevice | undefined;\n  get device() {\n    return this.#device;\n  }\n  set device(newDevice) {\n    if (this.#device == newDevice) {\n      _console.log(\"tried to assign the same BluetoothDevice\");\n      return;\n    }\n    if (this.#device) {\n      removeEventListeners(this.#device, this.#boundBluetoothDeviceEventListeners);\n    }\n    if (newDevice) {\n      addEventListeners(newDevice, this.#boundBluetoothDeviceEventListeners);\n    }\n    this.#device = newDevice;\n  }\n\n  get server(): BluetoothRemoteGATTServer | undefined {\n    return this.#device?.gatt;\n  }\n  get isConnected() {\n    return this.server?.connected || false;\n  }\n\n  #services: Map<BluetoothServiceName, BluetoothService> = new Map();\n  #characteristics: Map<BluetoothCharacteristicName, BluetoothCharacteristic> = new Map();\n\n  async connect() {\n    await super.connect();\n\n    try {\n      const device = await bluetooth!.requestDevice({\n        filters: [{ services: serviceUUIDs }],\n        optionalServices: isInBrowser ? optionalServiceUUIDs : [],\n      });\n\n      _console.log(\"got BluetoothDevice\");\n      this.device = device;\n\n      _console.log(\"connecting to device...\");\n      const server = await this.server!.connect();\n      _console.log(`connected to device? ${server.connected}`);\n\n      await this.#getServicesAndCharacteristics();\n\n      _console.log(\"fully connected\");\n\n      this.status = \"connected\";\n    } catch (error) {\n      _console.error(error);\n      this.status = \"notConnected\";\n      this.server?.disconnect();\n      this.#removeEventListeners();\n    }\n  }\n  async #getServicesAndCharacteristics() {\n    this.#removeEventListeners();\n\n    _console.log(\"getting services...\");\n    const services = await this.server!.getPrimaryServices();\n    _console.log(\"got services\", services);\n    const service = await this.server!.getPrimaryService(\"6e400001-b5a3-f393-e0a9-e50e24dcca9e\");\n    _console.log(\"got nus service\", service);\n\n    _console.log(\"getting characteristics...\");\n    for (const serviceIndex in services) {\n      const service = services[serviceIndex] as BluetoothService;\n      _console.log({ service });\n      const serviceName = getServiceNameFromUUID(service.uuid)!;\n      _console.assertWithError(serviceName, `no name found for service uuid \"${service.uuid}\"`);\n      _console.log(`got \"${serviceName}\" service`);\n      service.name = serviceName;\n      this.#services.set(serviceName, service);\n      _console.log(`getting characteristics for \"${serviceName}\" service`);\n      const characteristics = await service.getCharacteristics();\n      _console.log(`got characteristics for \"${serviceName}\" service`);\n      for (const characteristicIndex in characteristics) {\n        const characteristic = characteristics[characteristicIndex] as BluetoothCharacteristic;\n        _console.log({ characteristic });\n        const characteristicName = getCharacteristicNameFromUUID(characteristic.uuid)!;\n        _console.assertWithError(\n          Boolean(characteristicName),\n          `no name found for characteristic uuid \"${characteristic.uuid}\" in \"${serviceName}\" service`\n        );\n        _console.log(`got \"${characteristicName}\" characteristic in \"${serviceName}\" service`);\n        characteristic.name = characteristicName;\n        this.#characteristics.set(characteristicName, characteristic);\n        addEventListeners(characteristic, this.#boundBluetoothCharacteristicEventListeners);\n        const characteristicProperties = characteristic.properties || getCharacteristicProperties(characteristicName);\n        if (characteristicProperties.notify) {\n          _console.log(`starting notifications for \"${characteristicName}\" characteristic`);\n          await characteristic.startNotifications();\n        }\n        if (characteristicProperties.read) {\n          _console.log(`reading \"${characteristicName}\" characteristic...`);\n          await characteristic.readValue();\n          if (isInBluefy || isInWebBLE) {\n            this.#onCharacteristicValueChanged(characteristic);\n          }\n        }\n      }\n    }\n  }\n  async #removeEventListeners() {\n    if (this.device) {\n      removeEventListeners(this.device, this.#boundBluetoothDeviceEventListeners);\n    }\n\n    const promises = Array.from(this.#characteristics.keys()).map((characteristicName) => {\n      const characteristic = this.#characteristics.get(characteristicName)!;\n      removeEventListeners(characteristic, this.#boundBluetoothCharacteristicEventListeners);\n      const characteristicProperties = characteristic.properties || getCharacteristicProperties(characteristicName);\n      if (characteristicProperties.notify) {\n        _console.log(`stopping notifications for \"${characteristicName}\" characteristic`);\n        return characteristic.stopNotifications();\n      }\n    });\n\n    return Promise.allSettled(promises);\n  }\n  async disconnect() {\n    await this.#removeEventListeners();\n    await super.disconnect();\n    this.server?.disconnect();\n    this.status = \"notConnected\";\n  }\n\n  #onCharacteristicvaluechanged(event: Event) {\n    _console.log(\"oncharacteristicvaluechanged\");\n\n    const characteristic = event.target as BluetoothCharacteristic;\n    this.#onCharacteristicValueChanged(characteristic);\n  }\n\n  #onCharacteristicValueChanged(characteristic: BluetoothCharacteristic) {\n    _console.log(\"onCharacteristicValue\");\n\n    const characteristicName = characteristic.name!;\n    _console.assertWithError(\n      Boolean(characteristicName),\n      `no name found for characteristic with uuid \"${characteristic.uuid}\"`\n    );\n\n    _console.log(`oncharacteristicvaluechanged for \"${characteristicName}\" characteristic`);\n    const dataView = characteristic.value!;\n    _console.assertWithError(dataView, `no data found for \"${characteristicName}\" characteristic`);\n    _console.log(`data for \"${characteristicName}\" characteristic`, Array.from(new Uint8Array(dataView.buffer)));\n\n    try {\n      this.onCharacteristicValueChanged(characteristicName, dataView);\n    } catch (error) {\n      _console.error(error);\n    }\n  }\n\n  async writeCharacteristic(characteristicName: BluetoothCharacteristicName, data: ArrayBuffer) {\n    super.writeCharacteristic(characteristicName, data);\n\n    const characteristic = this.#characteristics.get(characteristicName)!;\n    _console.assertWithError(characteristic, `${characteristicName} characteristic not found`);\n    _console.log(\"writing characteristic\", characteristic, data);\n    const characteristicProperties = characteristic.properties || getCharacteristicProperties(characteristicName);\n    if (characteristicProperties.writeWithoutResponse) {\n      _console.log(\"writing without response\");\n      await characteristic.writeValueWithoutResponse(data);\n    } else {\n      _console.log(\"writing with response\");\n      await characteristic.writeValueWithResponse(data);\n    }\n    _console.log(\"wrote characteristic\");\n\n    if (characteristicProperties.read && !characteristicProperties.notify) {\n      _console.log(\"reading value after write...\");\n      await characteristic.readValue();\n      if (isInBluefy || isInWebBLE) {\n        this.#onCharacteristicValueChanged(characteristic);\n      }\n    }\n  }\n\n  #onGattserverdisconnected() {\n    _console.log(\"gattserverdisconnected\");\n    this.status = \"notConnected\";\n  }\n\n  get canReconnect() {\n    return Boolean(this.server && !this.server.connected && this.isInRange);\n  }\n  async reconnect() {\n    await super.reconnect();\n    _console.log(\"attempting to reconnect...\");\n    this.status = \"connecting\";\n    try {\n      await this.server!.connect();\n    } catch (error) {\n      _console.error(error);\n      this.isInRange = false;\n    }\n\n    if (this.isConnected) {\n      _console.log(\"successfully reconnected!\");\n      await this.#getServicesAndCharacteristics();\n      this.status = \"connected\";\n    } else {\n      _console.log(\"unable to reconnect\");\n      this.status = \"notConnected\";\n    }\n  }\n}\n\nexport default WebBluetoothConnectionManager;\n","import { createConsole } from \"./Console.ts\";\n\nconst _console = createConsole(\"MathUtils\", { log: true });\n\nexport function getInterpolation(value: number, min: number, max: number, span: number) {\n  if (span == undefined) {\n    span = max - min;\n  }\n  return (value - min) / span;\n}\n\nexport const Uint16Max = 2 ** 16;\n\nfunction removeLower2Bytes(number: number) {\n  const lower2Bytes = number % Uint16Max;\n  return number - lower2Bytes;\n}\n\nconst timestampThreshold = 60_000;\n\nexport function parseTimestamp(dataView: DataView, byteOffset: number) {\n  const now = Date.now();\n  const nowWithoutLower2Bytes = removeLower2Bytes(now);\n  const lower2Bytes = dataView.getUint16(byteOffset, true);\n  let timestamp = nowWithoutLower2Bytes + lower2Bytes;\n  if (Math.abs(now - timestamp) > timestampThreshold) {\n    _console.log(\"correcting timestamp delta\");\n    timestamp += Uint16Max * Math.sign(now - timestamp);\n  }\n  return timestamp;\n}\n\nexport interface Vector2 {\n  x: number;\n  y: number;\n}\n\nexport interface Vector3 extends Vector2 {\n  z: number;\n}\n\nexport interface Quaternion {\n  x: number;\n  y: number;\n  z: number;\n  w: number;\n}\n\nexport interface Euler {\n  heading: number;\n  pitch: number;\n  roll: number;\n}\n\nexport function clamp(value: number, min: number = 0, max: number = 1) {\n  return Math.max(min, Math.min(max, value));\n}\n","import { createConsole } from \"./utils/Console.ts\";\nimport autoBind from \"auto-bind\";\nimport { clamp } from \"./utils/MathUtils.ts\";\nimport { SendDataCallback } from \"./connection/BaseConnectionManager.ts\";\n\nconst _console = createConsole(\"VibrationManager\");\n\nexport const MaxNumberOfVibrations = 9;\nexport const MaxNumberOfVibrationSegments = MaxNumberOfVibrations * 2;\n\nclass VibrationManager {\n  constructor() {\n    autoBind(this);\n  }\n  sendUICommandsData!: SendDataCallback;\n\n  #createData(segments: number[]) {\n    const dataView = new DataView(new ArrayBuffer(2 + MaxNumberOfVibrationSegments));\n    let index = 0;\n    dataView.setUint8(index++, 0);\n    dataView.setUint8(index++, 2);\n\n    for (\n      let segmentIndex = 0;\n      segmentIndex < segments.length && segmentIndex < MaxNumberOfVibrationSegments;\n      segmentIndex++\n    ) {\n      let value = segments[segmentIndex];\n      value /= 10;\n      value = clamp(value, 0, 2 ** 8 - 1);\n      _console.log(`vibration segment #${segmentIndex}: ${value}`);\n      dataView.setUint8(index + segmentIndex, value);\n    }\n    return dataView;\n  }\n  async vibrate(segments: number[]) {\n    _console.log(\"triggering vibration segments\", segments);\n    const dataView = this.#createData(segments);\n    await this.sendUICommandsData(dataView?.buffer);\n  }\n}\n\nexport default VibrationManager;\n","import { ConnectionStatus } from \"./connection/BaseConnectionManager.ts\";\nimport WebBluetoothConnectionManager from \"./connection/bluetooth/WebBluetoothConnectionManager.ts\";\nimport Device, { BoundDeviceEventListeners, DeviceEventMap } from \"./Device.ts\";\nimport { createConsole } from \"./utils/Console.ts\";\nimport { isInBluefy, isInBrowser } from \"./utils/environment.ts\";\nimport EventDispatcher, { BoundEventListeners, Event, EventListenerMap, EventMap } from \"./utils/EventDispatcher.ts\";\nimport { addEventListeners } from \"./utils/EventUtils.ts\";\n\nconst _console = createConsole(\"DeviceManager\", { log: true });\n\nexport interface LocalStorageDeviceInformation {\n  bluetoothId: string;\n}\n\nexport interface LocalStorageConfiguration {\n  devices: LocalStorageDeviceInformation[];\n}\n\nexport const DeviceManagerEventTypes = [\n  \"deviceConnected\",\n  \"deviceDisconnected\",\n  \"deviceIsConnected\",\n  \"availableDevices\",\n  \"connectedDevices\",\n] as const;\nexport type DeviceManagerEventType = (typeof DeviceManagerEventTypes)[number];\n\ninterface DeviceManagerEventMessage {\n  device: Device;\n}\nexport interface DeviceManagerEventMessages {\n  deviceConnected: DeviceManagerEventMessage;\n  deviceDisconnected: DeviceManagerEventMessage;\n  deviceIsConnected: DeviceManagerEventMessage;\n  availableDevices: { availableDevices: Device[] };\n  connectedDevices: { connectedDevices: Device[] };\n}\n\nexport type DeviceManagerEventDispatcher = EventDispatcher<\n  DeviceManager,\n  DeviceManagerEventType,\n  DeviceManagerEventMessages\n>;\nexport type DeviceManagerEventMap = EventMap<typeof Device, DeviceManagerEventType, DeviceManagerEventMessages>;\nexport type DeviceManagerEventListenerMap = EventListenerMap<\n  typeof Device,\n  DeviceManagerEventType,\n  DeviceManagerEventMessages\n>;\nexport type DeviceManagerEvent = Event<typeof Device, DeviceManagerEventType, DeviceManagerEventMessages>;\nexport type BoundDeviceManagerEventListeners = BoundEventListeners<\n  typeof Device,\n  DeviceManagerEventType,\n  DeviceManagerEventMessages\n>;\n\nclass DeviceManager {\n  static readonly shared = new DeviceManager();\n\n  constructor() {\n    if (DeviceManager.shared && this != DeviceManager.shared) {\n      throw Error(\"DeviceManager is a singleton - use DeviceManager.shared\");\n    }\n\n    if (this.CanUseLocalStorage) {\n      this.UseLocalStorage = true;\n    }\n  }\n\n  // DEVICE LISTENERS\n  #boundDeviceEventListeners: BoundDeviceEventListeners = {\n    isConnected: this.#OnDeviceIsConnected.bind(this),\n  };\n  /** @private */\n  onDevice(device: Device) {\n    addEventListeners(device, this.#boundDeviceEventListeners);\n  }\n\n  // CONNECTION STATUS\n  /** @private */\n  OnDeviceConnectionStatusUpdated(device: Device, connectionStatus: ConnectionStatus) {\n    if (connectionStatus == \"notConnected\" && !device.canReconnect && this.#AvailableDevices.includes(device)) {\n      const deviceIndex = this.#AvailableDevices.indexOf(device);\n      this.AvailableDevices.splice(deviceIndex, 1);\n      this.#DispatchAvailableDevices();\n    }\n  }\n\n  // CONNECTED DEVICES\n\n  #ConnectedDevices: Device[] = [];\n  get ConnectedDevices() {\n    return this.#ConnectedDevices;\n  }\n\n  #UseLocalStorage = false;\n  get UseLocalStorage() {\n    return this.#UseLocalStorage;\n  }\n  set UseLocalStorage(newUseLocalStorage) {\n    this.#AssertLocalStorage();\n    _console.assertTypeWithError(newUseLocalStorage, \"boolean\");\n    this.#UseLocalStorage = newUseLocalStorage;\n    if (this.#UseLocalStorage && !this.#LocalStorageConfiguration) {\n      this.#LoadFromLocalStorage();\n    }\n  }\n\n  #DefaultLocalStorageConfiguration: LocalStorageConfiguration = {\n    devices: [],\n  };\n  #LocalStorageConfiguration?: LocalStorageConfiguration;\n\n  get CanUseLocalStorage() {\n    return isInBrowser && window.localStorage;\n  }\n\n  #AssertLocalStorage() {\n    _console.assertWithError(isInBrowser, \"localStorage is only available in the browser\");\n    _console.assertWithError(window.localStorage, \"localStorage not found\");\n  }\n  #LocalStorageKey = \"TS.Device\";\n  #SaveToLocalStorage() {\n    this.#AssertLocalStorage();\n    localStorage.setItem(this.#LocalStorageKey, JSON.stringify(this.#LocalStorageConfiguration));\n  }\n  async #LoadFromLocalStorage() {\n    this.#AssertLocalStorage();\n    let localStorageString = localStorage.getItem(this.#LocalStorageKey);\n    if (typeof localStorageString != \"string\") {\n      _console.log(\"no info found in localStorage\");\n      this.#LocalStorageConfiguration = Object.assign({}, this.#DefaultLocalStorageConfiguration);\n      this.#SaveToLocalStorage();\n      return;\n    }\n    try {\n      const configuration = JSON.parse(localStorageString);\n      _console.log({ configuration });\n      this.#LocalStorageConfiguration = configuration;\n      if (this.CanGetDevices) {\n        await this.GetDevices(); // redundant?\n      }\n    } catch (error) {\n      _console.error(error);\n    }\n  }\n\n  #UpdateLocalStorageConfigurationForDevice(device: Device) {\n    if (device.connectionType != \"webBluetooth\") {\n      _console.log(\"localStorage is only for webBluetooth devices\");\n      return;\n    }\n    this.#AssertLocalStorage();\n    const deviceInformationIndex = this.#LocalStorageConfiguration!.devices.findIndex((deviceInformation) => {\n      return deviceInformation.bluetoothId == device.bluetoothId;\n    });\n    if (deviceInformationIndex == -1) {\n      return;\n    }\n    this.#SaveToLocalStorage();\n  }\n\n  // AVAILABLE DEVICES\n  #AvailableDevices: Device[] = [];\n  get AvailableDevices() {\n    return this.#AvailableDevices;\n  }\n\n  get CanGetDevices() {\n    return isInBrowser && navigator.bluetooth?.getDevices;\n  }\n  /**\n   * retrieves devices already connected via web bluetooth in other tabs/windows\n   *\n   * _only available on web-bluetooth enabled browsers_\n   */\n  async GetDevices(): Promise<Device[] | undefined> {\n    if (!isInBrowser) {\n      _console.warn(\"GetDevices is only available in the browser\");\n      return;\n    }\n\n    if (!navigator.bluetooth) {\n      _console.warn(\"bluetooth is not available in this browser\");\n      return;\n    }\n\n    if (isInBluefy) {\n      _console.warn(\"bluefy lists too many devices...\");\n      return;\n    }\n\n    if (!navigator.bluetooth.getDevices) {\n      _console.warn(\"bluetooth.getDevices() is not available in this browser\");\n      return;\n    }\n\n    if (!this.CanGetDevices) {\n      _console.log(\"CanGetDevices is false\");\n      return;\n    }\n\n    if (!this.#LocalStorageConfiguration) {\n      this.#LoadFromLocalStorage();\n    }\n\n    const configuration = this.#LocalStorageConfiguration!;\n    if (!configuration.devices || configuration.devices.length == 0) {\n      _console.log(\"no devices found in configuration\");\n      return;\n    }\n\n    const bluetoothDevices = await navigator.bluetooth.getDevices();\n\n    _console.log({ bluetoothDevices });\n\n    bluetoothDevices.forEach((bluetoothDevice) => {\n      if (!bluetoothDevice.gatt) {\n        return;\n      }\n      let deviceInformation = configuration.devices.find(\n        (deviceInformation) => bluetoothDevice.id == deviceInformation.bluetoothId\n      );\n      if (!deviceInformation) {\n        return;\n      }\n\n      let existingConnectedDevice = this.ConnectedDevices.filter(\n        (device) => device.connectionType == \"webBluetooth\"\n      ).find((device) => device.bluetoothId == bluetoothDevice.id);\n\n      const existingAvailableDevice = this.AvailableDevices.filter(\n        (device) => device.connectionType == \"webBluetooth\"\n      ).find((device) => device.bluetoothId == bluetoothDevice.id);\n      if (existingAvailableDevice) {\n        if (\n          existingConnectedDevice &&\n          existingConnectedDevice?.bluetoothId == existingAvailableDevice.bluetoothId &&\n          existingConnectedDevice != existingAvailableDevice\n        ) {\n          this.AvailableDevices[this.#AvailableDevices.indexOf(existingAvailableDevice)] = existingConnectedDevice;\n        }\n        return;\n      }\n\n      if (existingConnectedDevice) {\n        this.AvailableDevices.push(existingConnectedDevice);\n        return;\n      }\n\n      const device = new Device();\n      const connectionManager = new WebBluetoothConnectionManager();\n      connectionManager.device = bluetoothDevice;\n      if (bluetoothDevice.name) {\n        // FILL - update device name\n      }\n      device.connectionManager = connectionManager;\n      this.AvailableDevices.push(device);\n    });\n    this.#DispatchAvailableDevices();\n    return this.AvailableDevices;\n  }\n\n  // STATIC EVENTLISTENERS\n\n  #EventDispatcher: DeviceManagerEventDispatcher = new EventDispatcher(this as DeviceManager, DeviceManagerEventTypes);\n\n  get AddEventListener() {\n    return this.#EventDispatcher.addEventListener;\n  }\n  get #DispatchEvent() {\n    return this.#EventDispatcher.dispatchEvent;\n  }\n  get RemoveEventListener() {\n    return this.#EventDispatcher.removeEventListener;\n  }\n  get RemoveEventListeners() {\n    return this.#EventDispatcher.removeEventListeners;\n  }\n  get RemoveAllEventListeners() {\n    return this.#EventDispatcher.removeAllEventListeners;\n  }\n\n  #OnDeviceIsConnected(event: DeviceEventMap[\"isConnected\"]) {\n    const { target: device } = event;\n    if (device.isConnected) {\n      if (!this.#ConnectedDevices.includes(device)) {\n        _console.log(\"adding device\", device);\n        this.#ConnectedDevices.push(device);\n        if (this.UseLocalStorage && device.connectionType == \"webBluetooth\") {\n          const deviceInformation: LocalStorageDeviceInformation = {\n            bluetoothId: device.bluetoothId!,\n          };\n          const deviceInformationIndex = this.#LocalStorageConfiguration!.devices.findIndex(\n            (_deviceInformation) => _deviceInformation.bluetoothId == deviceInformation.bluetoothId\n          );\n          if (deviceInformationIndex == -1) {\n            this.#LocalStorageConfiguration!.devices.push(deviceInformation);\n          } else {\n            this.#LocalStorageConfiguration!.devices[deviceInformationIndex] = deviceInformation;\n          }\n          this.#SaveToLocalStorage();\n        }\n        this.#DispatchEvent(\"deviceConnected\", { device });\n        this.#DispatchEvent(\"deviceIsConnected\", { device });\n        this.#DispatchConnectedDevices();\n      } else {\n        _console.log(\"device already included\");\n      }\n    } else {\n      if (this.#ConnectedDevices.includes(device)) {\n        _console.log(\"removing device\", device);\n        this.#ConnectedDevices.splice(this.#ConnectedDevices.indexOf(device), 1);\n        this.#DispatchEvent(\"deviceDisconnected\", { device });\n        this.#DispatchEvent(\"deviceIsConnected\", { device });\n        this.#DispatchConnectedDevices();\n      } else {\n        _console.log(\"device already not included\");\n      }\n    }\n    if (this.CanGetDevices) {\n      this.GetDevices();\n    }\n    if (device.isConnected && !this.AvailableDevices.includes(device)) {\n      const existingAvailableDevice = this.AvailableDevices.find(\n        (_device) => _device.bluetoothId == device.bluetoothId\n      );\n      _console.log({ existingAvailableDevice });\n      if (existingAvailableDevice) {\n        this.AvailableDevices[this.AvailableDevices.indexOf(existingAvailableDevice)] = device;\n      } else {\n        this.AvailableDevices.push(device);\n      }\n      this.#DispatchAvailableDevices();\n    }\n  }\n\n  #DispatchAvailableDevices() {\n    _console.log({ AvailableDevices: this.AvailableDevices });\n    this.#DispatchEvent(\"availableDevices\", { availableDevices: this.AvailableDevices });\n  }\n  #DispatchConnectedDevices() {\n    _console.log({ ConnectedDevices: this.ConnectedDevices });\n    this.#DispatchEvent(\"connectedDevices\", { connectedDevices: this.ConnectedDevices });\n  }\n}\n\nexport default DeviceManager.shared;\n","import { createConsole } from \"./utils/Console.ts\";\nimport autoBind from \"auto-bind\";\nimport { SendDataCallback } from \"./connection/BaseConnectionManager.ts\";\nimport { concatenateArrayBuffers } from \"./utils/ArrayBufferUtils.ts\";\nimport {\n  assertValidRawSensorSensitivity,\n  assertValidRawSensorSensitivityForType,\n  DefaultRawSensorSensitivity,\n  RawSensorSensitivity,\n  RawSensorType,\n  RawSensorTypes,\n} from \"./utils/RawSensorUtils.ts\";\nimport Timer from \"./utils/Timer.ts\";\n\nconst _console = createConsole(\"InputManager\");\n\nexport const InputModes = [\n  \"controller\",\n  \"text\",\n  \"rawSensor\",\n  \"controllerWithMouse\",\n  \"controllerWithMouseAndKeyboard\",\n] as const;\nexport type InputMode = (typeof InputModes)[number];\n\n// https://github.com/TapWithUs/tap-ios-sdk/blob/155ab66658662a19d39b231264a3efdd8b5b7e7b/TAPKit-iOS/TAPInputMode/TAPInputMode.swift#L20\nconst InputModeBytes: { [mode in InputMode]: number } = {\n  controller: 0x1,\n  text: 0x0,\n  rawSensor: 0xa,\n  controllerWithMouse: 0x3,\n  controllerWithMouseAndKeyboard: 0x5,\n};\n\nclass InputManager {\n  constructor() {\n    autoBind(this);\n  }\n  sendRxData!: SendDataCallback;\n\n  #sensitivity: RawSensorSensitivity = Object.assign({}, DefaultRawSensorSensitivity);\n  get sensitivity() {\n    return this.#sensitivity;\n  }\n  set sensitivity(newSensitivity) {\n    Object.assign(this.#sensitivity, newSensitivity);\n  }\n\n  setSensitivityForType(rawSensorType: RawSensorType, index: number) {\n    assertValidRawSensorSensitivityForType(rawSensorType, index);\n    _console.log(`setting ${rawSensorType} sensitivity index to ${index}`);\n    this.#sensitivity[rawSensorType] = index;\n  }\n\n  #mode: InputMode = \"controller\";\n  get mode() {\n    return this.#mode;\n  }\n  set mode(newMode) {\n    this.#assertValidMode(newMode);\n    if (this.mode == newMode) {\n      _console.log(`redundant mode assignment \"${newMode}\"`);\n      return;\n    }\n    this.#mode = newMode;\n\n    if (this.#timer.isRunning) {\n      this.#timer.restart(true);\n    }\n  }\n  setMode(newMode: InputMode) {\n    this.mode = newMode;\n  }\n  #assertValidMode(mode: InputMode) {\n    _console.assertEnumWithError(mode, InputModes);\n  }\n\n  // https://github.com/TapWithUs/tap-ios-sdk/blob/155ab66658662a19d39b231264a3efdd8b5b7e7b/TAPKit-iOS/TAPInputMode/TAPInputMode.swift#L59\n  #createData() {\n    const modeByte = InputModeBytes[this.mode];\n    let sensitivityFactorIndices: number[] = [];\n    if (this.mode == \"rawSensor\") {\n      _console.assertWithError(this.sensitivity, \"no sensitivity defined for rawSensor input mode\");\n      assertValidRawSensorSensitivity(this.sensitivity!);\n      // https://github.com/TapWithUs/tap-ios-sdk/blob/master/TAPKit-iOS/Helpers/RawSensorData/TAPRawSensorSensitivity.swift#L105\n      RawSensorTypes.forEach((rawSensorType) => {\n        sensitivityFactorIndices.push(this.sensitivity![rawSensorType]);\n      });\n    }\n    const data = concatenateArrayBuffers(0x3, 0xc, 0x0, modeByte, sensitivityFactorIndices);\n    return data;\n  }\n\n  #timer = new Timer(this.#sendModeData.bind(this), 10 * 1000);\n  start() {\n    this.#timer.start(true);\n  }\n  stop() {\n    this.#timer.stop();\n  }\n\n  #sendModeData() {\n    _console.log(\"sending mode data...\");\n    const data = this.#createData();\n    this.sendRxData(data);\n  }\n}\n\nexport default InputManager;\n","import { createConsole } from \"./utils/Console.ts\";\nimport autoBind from \"auto-bind\";\nimport { SendDataCallback } from \"./connection/BaseConnectionManager.ts\";\nimport { concatenateArrayBuffers } from \"./utils/ArrayBufferUtils.ts\";\nimport Timer from \"./utils/Timer.ts\";\n\nconst _console = createConsole(\"XRStateManager\");\n\nexport const XRStates = [\"user\", \"airMouse\", \"tapping\", \"dontSend\"] as const;\nexport type XRState = (typeof XRStates)[number];\n\n// https://github.com/TapWithUs/tap-ios-sdk/blob/master/TAPKit-iOS/TAPXRState/TAPXRState.swift\nconst XRStateBytes: { [state in XRState]?: number } = {\n  user: 0x3,\n  airMouse: 0x1,\n  tapping: 0x2,\n};\n\nclass XRStateManager {\n  constructor() {\n    autoBind(this);\n  }\n  sendRxData!: SendDataCallback;\n\n  #state: XRState = \"user\";\n  get state() {\n    return this.#state;\n  }\n  set state(newState) {\n    this.#assertValidState(newState);\n    if (this.state == newState) {\n      _console.log(`redundant state assignment \"${newState}\"`);\n      return;\n    }\n    this.#state = newState;\n\n    if (this.#timer.isRunning) {\n      this.#timer.restart(true);\n    }\n  }\n  setState(newState: XRState) {\n    this.state = newState;\n  }\n  #assertValidState(state: XRState) {\n    _console.assertEnumWithError(state, XRStates);\n  }\n\n  // https://github.com/TapWithUs/tap-ios-sdk/blob/master/TAPKit-iOS/TAPXRState/TAPXRState.swift#L41\n  #createData() {\n    const stateByte = XRStateBytes[this.state];\n    _console.assert(stateByte != undefined, `no stateByte found for state \"${this.state}\"`);\n    const data = concatenateArrayBuffers(0x3, 0xd, 0x0, stateByte);\n    return data;\n  }\n\n  #timer = new Timer(this.#sendStateData.bind(this), 10 * 1000);\n  start() {\n    this.#timer.start(true);\n  }\n  stop() {\n    this.#timer.stop();\n  }\n\n  #sendStateData() {\n    if (this.state == \"dontSend\") {\n      return;\n    }\n    _console.log(\"sending state data...\");\n    const data = this.#createData();\n    this.sendRxData(data);\n  }\n}\n\nexport default XRStateManager;\n","import { createConsole } from \"./utils/Console.ts\";\nimport EventDispatcher, { BoundEventListeners, Event, EventListenerMap, EventMap } from \"./utils/EventDispatcher.ts\";\nimport BaseConnectionManager, {\n  ConnectionStatus,\n  ConnectionMessageType,\n  BatteryLevelMessageTypes,\n  ConnectionEventTypes,\n  ConnectionStatusEventMessages,\n} from \"./connection/BaseConnectionManager.ts\";\nimport { isInBrowser, isInNode } from \"./utils/environment.ts\";\nimport WebBluetoothConnectionManager from \"./connection/bluetooth/WebBluetoothConnectionManager.ts\";\nimport VibrationManager from \"./VibrationManager.ts\";\nimport DeviceInformationManager, {\n  DeviceInformationEventDispatcher,\n  DeviceInformationEventTypes,\n  DeviceInformationMessageType,\n  DeviceInformationMessageTypes,\n  DeviceInformationEventMessages,\n} from \"./DeviceInformationManager.ts\";\nimport DeviceManager from \"./DeviceManager.ts\";\nimport InputManager from \"./InputManager.ts\";\nimport RawSensorManager from \"./RawSensorManager.ts\";\nimport TapDataManager, {\n  TapDataEventDispatcher,\n  TapDataEventMessages,\n  TapDataEventTypes,\n  TapDataMessageType,\n  TapDataMessageTypes,\n} from \"./TapDataManager.ts\";\nimport MouseDataManager, {\n  MouseDataEventDispatcher,\n  MouseDataEventMessages,\n  MouseDataEventTypes,\n  MouseDataMessageType,\n  MouseDataMessageTypes,\n} from \"./MouseDataManager.ts\";\nimport AirGestureManager, {\n  AirGestureEventDispatcher,\n  AirGestureEventMessages,\n  AirGestureEventTypes,\n  AirGestureMessageType,\n  AirGestureMessageTypes,\n} from \"./AirGestureManager.ts\";\nimport TxManager, {\n  TxEventDispatcher,\n  TxEventMessages,\n  TxEventTypes,\n  TxMessageType,\n  TxMessageTypes,\n} from \"./TxManager.ts\";\nimport XRStateManager from \"./XRStateManager.ts\";\n\nconst _console = createConsole(\"Device\", { log: true });\n\nexport const DeviceEventTypes = [\n  \"connectionMessage\",\n  ...ConnectionEventTypes,\n  ...BatteryLevelMessageTypes,\n  ...DeviceInformationEventTypes,\n  ...TapDataEventTypes,\n  ...MouseDataEventTypes,\n  ...AirGestureEventTypes,\n  ...TxEventTypes,\n] as const;\nexport type DeviceEventType = (typeof DeviceEventTypes)[number];\n\nexport interface DeviceEventMessages\n  extends ConnectionStatusEventMessages,\n    DeviceInformationEventMessages,\n    TapDataEventMessages,\n    MouseDataEventMessages,\n    AirGestureEventMessages,\n    TxEventMessages {\n  batteryLevel: { batteryLevel: number };\n  connectionMessage: { messageType: ConnectionMessageType; dataView: DataView };\n}\n\nexport type DeviceEventDispatcher = EventDispatcher<Device, DeviceEventType, DeviceEventMessages>;\nexport type DeviceEvent = Event<Device, DeviceEventType, DeviceEventMessages>;\nexport type DeviceEventMap = EventMap<Device, DeviceEventType, DeviceEventMessages>;\nexport type DeviceEventListenerMap = EventListenerMap<Device, DeviceEventType, DeviceEventMessages>;\nexport type BoundDeviceEventListeners = BoundEventListeners<Device, DeviceEventType, DeviceEventMessages>;\n\nclass Device {\n  get bluetoothId() {\n    return this.#connectionManager?.bluetoothId;\n  }\n  get name() {\n    return this.#connectionManager?.name;\n  }\n\n  constructor() {\n    this.#deviceInformationManager.eventDispatcher = this.#eventDispatcher as DeviceInformationEventDispatcher;\n\n    this.#inputManager.sendRxData = this.sendRxData;\n    this.#xrStateManager.sendRxData = this.sendRxData;\n\n    this.#tapDataManager.eventDispatcher = this.#eventDispatcher as TapDataEventDispatcher;\n    this.#mouseDataManager.eventDispatcher = this.#eventDispatcher as MouseDataEventDispatcher;\n    this.#airGestureManager.eventDispatcher = this.#eventDispatcher as AirGestureEventDispatcher;\n    this.#txManager.eventDispatcher = this.#eventDispatcher as TxEventDispatcher;\n\n    this.#vibrationManager.sendUICommandsData = this.sendUICommandsData;\n\n    this.#txManager.rawSensorSensitivity = this.#inputManager.sensitivity;\n\n    this.addEventListener(\"hardwareRevision\", () => {\n      // FILL - check feature support\n    });\n\n    this.addEventListener(\"isConnected\", () => {\n      if (this.isConnected) {\n        this.#inputManager.start();\n      } else {\n        this.#inputManager.stop();\n      }\n    });\n\n    DeviceManager.onDevice(this);\n    if (isInBrowser) {\n      window.addEventListener(\"beforeunload\", () => {\n        if (this.isConnected) {\n          // FILL\n        }\n      });\n    }\n    if (isInNode) {\n      /** can add more node leave handlers https://gist.github.com/hyrious/30a878f6e6a057f09db87638567cb11a */\n      process.on(\"exit\", () => {\n        if (this.isConnected) {\n          // FILL\n        }\n      });\n    }\n  }\n\n  static #DefaultConnectionManager(): BaseConnectionManager {\n    return new WebBluetoothConnectionManager();\n  }\n\n  #eventDispatcher: DeviceEventDispatcher = new EventDispatcher(this as Device, DeviceEventTypes);\n  get addEventListener() {\n    return this.#eventDispatcher.addEventListener;\n  }\n  get #dispatchEvent() {\n    return this.#eventDispatcher.dispatchEvent;\n  }\n  get removeEventListener() {\n    return this.#eventDispatcher.removeEventListener;\n  }\n  get waitForEvent() {\n    return this.#eventDispatcher.waitForEvent;\n  }\n  get removeEventListeners() {\n    return this.#eventDispatcher.removeEventListeners;\n  }\n  get removeAllEventListeners() {\n    return this.#eventDispatcher.removeAllEventListeners;\n  }\n\n  // CONNECTION MANAGER\n\n  #connectionManager?: BaseConnectionManager;\n  get connectionManager() {\n    return this.#connectionManager;\n  }\n  set connectionManager(newConnectionManager) {\n    if (this.connectionManager == newConnectionManager) {\n      _console.log(\"same connectionManager is already assigned\");\n      return;\n    }\n\n    if (this.connectionManager) {\n      this.connectionManager.onStatusUpdated = undefined;\n      this.connectionManager.onMessageReceived = undefined;\n      this.connectionManager.onMessagesReceived = undefined;\n    }\n    if (newConnectionManager) {\n      newConnectionManager.onStatusUpdated = this.#onConnectionStatusUpdated.bind(this);\n      newConnectionManager.onMessageReceived = this.#onConnectionMessageReceived.bind(this);\n      newConnectionManager.onMessagesReceived = this.#onConnectionMessagesReceived.bind(this);\n    }\n\n    this.#connectionManager = newConnectionManager;\n    _console.log(\"assigned new connectionManager\", this.#connectionManager);\n  }\n\n  async #sendUICommandsData(data: ArrayBuffer) {\n    await this.#connectionManager?.sendUICommandsData(data);\n  }\n  private sendUICommandsData = this.#sendUICommandsData.bind(this);\n\n  async #sendRxData(data: ArrayBuffer) {\n    await this.#connectionManager?.sendRxData(data);\n  }\n  private sendRxData = this.#sendRxData.bind(this);\n\n  async connect() {\n    if (!this.connectionManager) {\n      this.connectionManager = Device.#DefaultConnectionManager();\n    }\n    this.#clear();\n    return this.connectionManager.connect();\n  }\n  #isConnected = false;\n  get isConnected() {\n    return this.#isConnected;\n  }\n  /** @throws {Error} if not connected */\n  #assertIsConnected() {\n    _console.assertWithError(this.isConnected, \"notConnected\");\n  }\n\n  get canReconnect() {\n    return this.connectionManager?.canReconnect;\n  }\n  #assertCanReconnect() {\n    _console.assertWithError(this.canReconnect, \"cannot reconnect to device\");\n  }\n  async reconnect() {\n    this.#assertCanReconnect();\n    this.#clear();\n    return this.connectionManager?.reconnect();\n  }\n\n  static async Connect() {\n    const device = new Device();\n    await device.connect();\n    return device;\n  }\n\n  static #ReconnectOnDisconnection = false;\n  static get ReconnectOnDisconnection() {\n    return this.#ReconnectOnDisconnection;\n  }\n  static set ReconnectOnDisconnection(newReconnectOnDisconnection) {\n    _console.assertTypeWithError(newReconnectOnDisconnection, \"boolean\");\n    this.#ReconnectOnDisconnection = newReconnectOnDisconnection;\n  }\n\n  #reconnectOnDisconnection = Device.ReconnectOnDisconnection;\n  get reconnectOnDisconnection() {\n    return this.#reconnectOnDisconnection;\n  }\n  set reconnectOnDisconnection(newReconnectOnDisconnection) {\n    _console.assertTypeWithError(newReconnectOnDisconnection, \"boolean\");\n    this.#reconnectOnDisconnection = newReconnectOnDisconnection;\n  }\n  #reconnectIntervalId?: NodeJS.Timeout | number;\n\n  get connectionType() {\n    return this.connectionManager?.type;\n  }\n  async disconnect() {\n    this.#assertIsConnected();\n    if (this.reconnectOnDisconnection) {\n      this.reconnectOnDisconnection = false;\n      this.addEventListener(\n        \"isConnected\",\n        () => {\n          this.reconnectOnDisconnection = true;\n        },\n        { once: true }\n      );\n    }\n\n    return this.connectionManager!.disconnect();\n  }\n\n  toggleConnection() {\n    if (this.isConnected) {\n      this.disconnect();\n    } else if (this.canReconnect) {\n      this.reconnect();\n    } else {\n      this.connect();\n    }\n  }\n\n  get connectionStatus(): ConnectionStatus {\n    switch (this.#connectionManager?.status) {\n      case \"connected\":\n        return this.isConnected ? \"connected\" : \"connecting\";\n      case \"notConnected\":\n      case \"connecting\":\n      case \"disconnecting\":\n        return this.#connectionManager.status;\n      default:\n        return \"notConnected\";\n    }\n  }\n  get isConnectionBusy() {\n    return this.connectionStatus == \"connecting\" || this.connectionStatus == \"disconnecting\";\n  }\n\n  #onConnectionStatusUpdated(connectionStatus: ConnectionStatus) {\n    _console.log({ connectionStatus });\n\n    if (connectionStatus == \"notConnected\") {\n      //this.#clear();\n\n      if (this.canReconnect && this.reconnectOnDisconnection) {\n        _console.log(\"starting reconnect interval...\");\n        this.#reconnectIntervalId = setInterval(() => {\n          _console.log(\"attempting reconnect...\");\n          this.reconnect();\n        }, 1000);\n      }\n    } else {\n      if (this.#reconnectIntervalId != undefined) {\n        _console.log(\"clearing reconnect interval\");\n        clearInterval(this.#reconnectIntervalId);\n        this.#reconnectIntervalId = undefined;\n      }\n    }\n\n    this.#checkConnection();\n\n    if (connectionStatus == \"connected\" && !this.#isConnected) {\n      // FILL\n    }\n\n    DeviceManager.OnDeviceConnectionStatusUpdated(this, connectionStatus);\n  }\n\n  #dispatchConnectionEvents(includeIsConnected: boolean = false) {\n    this.#dispatchEvent(\"connectionStatus\", { connectionStatus: this.connectionStatus });\n    this.#dispatchEvent(this.connectionStatus, {});\n    if (includeIsConnected) {\n      this.#dispatchEvent(\"isConnected\", { isConnected: this.isConnected });\n    }\n  }\n  #checkConnection() {\n    this.#isConnected = Boolean(this.connectionManager?.isConnected);\n\n    switch (this.connectionStatus) {\n      case \"connected\":\n        if (this.#isConnected) {\n          this.#dispatchConnectionEvents(true);\n        }\n        break;\n      case \"notConnected\":\n        this.#dispatchConnectionEvents(true);\n        break;\n      default:\n        this.#dispatchConnectionEvents(false);\n        break;\n    }\n  }\n\n  #clear() {\n    this.latestConnectionMessage.clear();\n    this.#deviceInformationManager.clear();\n  }\n\n  #onConnectionMessageReceived(messageType: ConnectionMessageType, dataView: DataView) {\n    _console.log({ messageType, dataView });\n    switch (messageType) {\n      case \"batteryLevel\":\n        const batteryLevel = dataView.getUint8(0);\n        _console.log(\"received battery level\", { batteryLevel });\n        this.#updateBatteryLevel(batteryLevel);\n        break;\n\n      default:\n        if (DeviceInformationMessageTypes.includes(messageType as DeviceInformationMessageType)) {\n          this.#deviceInformationManager.parseMessage(messageType as DeviceInformationMessageType, dataView);\n        } else if (TapDataMessageTypes.includes(messageType as TapDataMessageType)) {\n          this.#tapDataManager.parseMessage(messageType as TapDataMessageType, dataView);\n        } else if (MouseDataMessageTypes.includes(messageType as MouseDataMessageType)) {\n          this.#mouseDataManager.parseMessage(messageType as MouseDataMessageType, dataView);\n        } else if (AirGestureMessageTypes.includes(messageType as AirGestureMessageType)) {\n          this.#airGestureManager.parseMessage(messageType as AirGestureMessageType, dataView);\n        } else if (TxMessageTypes.includes(messageType as TxMessageType)) {\n          this.#txManager.parseMessage(messageType as TxMessageType, dataView);\n        } else {\n          throw Error(`uncaught messageType \"${messageType}\"`);\n        }\n      /*\n        if (FileTransferMessageTypes.includes(messageType as FileTransferMessageType)) {\n          this.#fileTransferManager.parseMessage(messageType as FileTransferMessageType, dataView);\n        } else if (TfliteMessageTypes.includes(messageType as TfliteMessageType)) {\n          this.#tfliteManager.parseMessage(messageType as TfliteMessageType, dataView);\n        } else if (SensorDataMessageTypes.includes(messageType as SensorDataMessageType)) {\n          this.#sensorDataManager.parseMessage(messageType as SensorDataMessageType, dataView);\n        } else if (FirmwareMessageTypes.includes(messageType as FirmwareMessageType)) {\n          this.#firmwareManager.parseMessage(messageType as FirmwareMessageType, dataView);\n        } else if (DeviceInformationMessageTypes.includes(messageType as DeviceInformationMessageType)) {\n          this.#deviceInformationManager.parseMessage(messageType as DeviceInformationMessageType, dataView);\n        } else if (InformationMessageTypes.includes(messageType as InformationMessageType)) {\n          this._informationManager.parseMessage(messageType as InformationMessageType, dataView);\n        } else if (SensorConfigurationMessageTypes.includes(messageType as SensorConfigurationMessageType)) {\n          this.#sensorConfigurationManager.parseMessage(messageType as SensorConfigurationMessageType, dataView);\n        } else {\n          throw Error(`uncaught messageType ${messageType}`);\n        }\n        */\n    }\n\n    this.latestConnectionMessage.set(messageType, dataView);\n    this.#dispatchEvent(\"connectionMessage\", { messageType, dataView });\n  }\n  #onConnectionMessagesReceived() {\n    if (!this.isConnected) {\n      this.#checkConnection();\n    }\n  }\n\n  latestConnectionMessage: Map<ConnectionMessageType, DataView> = new Map();\n\n  // DEVICE INFORMATION\n  #deviceInformationManager = new DeviceInformationManager();\n  get deviceInformation() {\n    return this.#deviceInformationManager.information;\n  }\n\n  // BATTERY LEVEL\n  #batteryLevel = 0;\n  get batteryLevel() {\n    return this.#batteryLevel;\n  }\n  #updateBatteryLevel(updatedBatteryLevel: number) {\n    _console.assertTypeWithError(updatedBatteryLevel, \"number\");\n    if (this.#batteryLevel == updatedBatteryLevel) {\n      _console.log(`duplicate batteryLevel assignment ${updatedBatteryLevel}`);\n      return;\n    }\n    this.#batteryLevel = updatedBatteryLevel;\n    _console.log({ updatedBatteryLevel: this.#batteryLevel });\n    this.#dispatchEvent(\"batteryLevel\", { batteryLevel: this.#batteryLevel });\n  }\n\n  // INPUT MODE\n  #inputManager = new InputManager();\n  get setInputMode() {\n    return this.#inputManager.setMode;\n  }\n  get setSensitivityForType() {\n    return this.#inputManager.setSensitivityForType;\n  }\n\n  // XR STATE\n  #xrStateManager = new XRStateManager();\n  get setXRState() {\n    return this.#xrStateManager.setState;\n  }\n\n  // TAP DATA\n  #tapDataManager = new TapDataManager();\n\n  // MOUSE DATA\n  #mouseDataManager = new MouseDataManager();\n\n  // AIR GESTURE\n  #airGestureManager = new AirGestureManager();\n\n  // TX\n  #txManager = new TxManager();\n\n  // VIBRATION\n  #vibrationManager = new VibrationManager();\n  /** [hapticsMs, pauseMs, hapticsMs, pauseMs...] */\n  get vibrate() {\n    return this.#vibrationManager.vibrate;\n  }\n\n  // SERVER SIDE\n  #isServerSide = false;\n  get isServerSide() {\n    return this.#isServerSide;\n  }\n  set isServerSide(newIsServerSide) {\n    if (this.#isServerSide == newIsServerSide) {\n      _console.log(\"redundant isServerSide assignment\");\n      return;\n    }\n    _console.log({ newIsServerSide });\n    this.#isServerSide = newIsServerSide;\n  }\n}\n\nexport default Device;\n","import { getInterpolation } from \"./MathUtils.ts\";\n\ninterface Range {\n  min: number;\n  max: number;\n  span: number;\n}\n\nconst initialRange: Range = { min: Infinity, max: -Infinity, span: 0 };\n\nclass RangeHelper {\n  #range: Range = Object.assign({}, initialRange);\n  get min() {\n    return this.#range.min;\n  }\n  get max() {\n    return this.#range.max;\n  }\n\n  set min(newMin) {\n    this.#range.min = newMin;\n    this.#range.max = Math.max(newMin, this.#range.max);\n    this.#updateSpan();\n  }\n  set max(newMax) {\n    this.#range.max = newMax;\n    this.#range.min = Math.min(newMax, this.#range.min);\n    this.#updateSpan();\n  }\n\n  #updateSpan() {\n    this.#range.span = this.#range.max - this.#range.min;\n  }\n\n  reset() {\n    Object.assign(this.#range, initialRange);\n  }\n\n  update(value: number) {\n    this.#range.min = Math.min(value, this.#range.min);\n    this.#range.max = Math.max(value, this.#range.max);\n    this.#updateSpan();\n  }\n\n  getNormalization(value: number, weightByRange: boolean) {\n    let normalization = getInterpolation(value, this.#range.min, this.#range.max, this.#range.span);\n    if (weightByRange) {\n      normalization *= this.#range.span;\n    }\n    return normalization || 0;\n  }\n\n  updateAndGetNormalization(value: number, weightByRange: boolean) {\n    this.update(value);\n    return this.getNormalization(value, weightByRange);\n  }\n}\n\nexport default RangeHelper;\n"],"names":["_console"],"mappings":"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;;;AAGA;AACE;;;AAKP;;;;ACjDD;AAKO;AAGA;AAYA;AAmBP;AASE;;;AAGA;AACE;;AAEF;AACE;;AAIF;AACE;;AAQF;;AAIA;AA2EA;AA9EE;;AAIF;;;;AAIE;AACA;AACE;;;AAGF;AACA;AACA;AAEA;AACE;;;AAEA;;;AAIJ;AACE;;AAyBF;AACE;AACA;AACA;;AAEF;AACE;;AAEF;AACE;AACA;;;AAGF;AACE;AACA;AACA;AACA;;;AAIA;;;AAIA;;AAWH;;AA1FG;AACF;;AAkCA;;AAIA;;AAIA;;AAIA;AAsCE;AACE;AACA;;AAEJ;;AChKF;AAqBgB;AACd;AACA;AACA;AACA;AACE;AACF;AACF;AAEgB;AACd;AACA;AACA;AACA;AACE;AACF;AACF;;ACrCA;AAOA;AACE;AACF;AAIA;AACE;;AAEA;AACF;AAEA;AACE;;AAEA;AACF;AAEA;AACE;AACF;AAEA;AACE;AACF;AAiCA;AACE;AACE;AACE;AACA;AACE;AACE;AACD;AACD;AACE;AACD;AACD;AACE;AACD;AACD;AACE;AACD;AACD;AACE;AACD;AACD;AACE;AACD;AACD;AACE;AACD;AACF;AACF;AACD;AACE;AACA;AACE;AACE;AACD;AACF;AACF;AACD;AACE;AACA;;;;;;;;;;;;AAYC;AACF;AACD;AACE;AACA;;;AAGC;AACF;AACF;AACF;AAEM;AACA;AACL;AACA;AACA;;AAE6B;AAEzB;;;AAGJ;;;AAGE;;;;;;;AAOF;AACF;AAEO;AACA;AAKP;AACE;;;;AAIA;;;AAGI;AACA;;AAEF;AAEF;AACF;AAEAA;AAEM;;AAKJ;AACA;;;;;AAKI;;;;;;;AAOF;AACA;AACF;AACA;AACF;AAEM;AAGJ;AACE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAKA;AACA;AACA;AACA;AACA;AACE;;;;AAMF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACE;;;;AAMF;AACA;AACA;AACA;AACE;;;;AAMF;AACA;AACA;AACA;AACE;;;AAIJ;AACF;;ACpQA;AAIA;AAAA;;;;;;AAKM;AAE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","x_google_ignoreList":[0,7]}